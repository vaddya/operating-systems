\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

\begin{itemize}
	\item Изучить принципы организации файловой системы ОС UNIX на примере Linux.
	\item Познакомиться с типами файлов исследуемой ФС.
	\item Проанализировать способы формирования жестких и символьных ссылок.
	\item Исследовать права владения и доступа, а также их сочетаемость.
\end{itemize}

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Иерархия файловой системы}

\subsection{Стандарт иерархии файловой системы}

Стандарт иерархии файловой системы (Filesystem Hierarchy Standard, FHS) унифицирует местонахождение файлов и каталогов с общим назначением в файловой системе UNIX. Для получения справки об используемой в ОС системе каталогов можно использовать man-страницу \code{hier(7)}.

На рисунке \ref{fig:fhs} изображен упрощенный вариант иерархии каталогов Linux. В FHS все файлы и каталоги находятся внутри корневого каталога (\code{/}), даже если они расположены на различных физических носителях. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\textwidth]{fhs}
	\caption{Иерархия каталогов Linux}
	\label{fig:fhs}
\end{figure}

\subsection{Описание иерархии каталогов}

К основным каталогам FHS относятся:
\begin{itemize}
	\item \code{/bin/} -- содержит исполняемые файлы, включая большинство основных команд системы UNIX, таких как \code{ls} и \code{cp}.
	\item \code{/boot/} -- содержит файлы загрузчика ядра (данные, которые используются до того, как ядро начинает исполнять программы пользователя).
	\item \code{/dev/} -- содержит файлы устройств.
	\item \code{/etc/} -- содержит конфигурационные файлы и каталоги, специфичные для данной конкретной системы (пароль
	пользователя, файлы загрузки, файлы устройств, сетевые настройки и др.).
	\item \code{/home/} -- содержит личные каталоги обычных пользователей.
	\item \code{/lib/} -- содержит динамические библиотеки, необходимые для работы программ из \code{/bin/}.
	\item \code{/media/} -- является точкой подключения съемных устройств (CD-ROM, флеш-накопители и др.).
	\item \code{/mnt/} -- содержит временно монтируемые файловые системы.
	\item \code{/root/} -- домашний каталог суперпользователя.
	\item \code{/opt/} -- может содержать ПО сторонних разработчиков.
	\item \code{/sbin/} -- содержит основные системные программы для администрирования и настройки системы 
	\item \code{/tmp/} -- предназначен для хранения временных файлов, создаваемых в процессе работы различных программ.(\code{init}, \code{iptables}, \code{ifconfig} и др.).
	\item \code{/usr/} -- вторичная иерархия для данных пользователя,  содержащая разделяемые данные, предназначенные только для чтения:
	\begin{itemize}[topsep=0em]
		\item \code{bin/} -- исполняемые файлы;
		\item \code{include/} -- стандартные заголовочные файлы;
		\item \code{lib/} -- объектные файлы и библиотеки;
		\item \code{local/} -- третичная иерархия для данных, специфичных для данного хоста;
		\item \code{sbin/} -- дополнительные системные программы (демоны различных сетевых сервисов);
		\item \code{share/} -- архитектурно-независимые данные.
	\end{itemize}
	\item \code{/var/} -- содержит файлы с изменяющимися данными: каталоги и файлы логирования (\code{log/}), временные файлы, сохраняемые между перезапусками системы (\code{tmp/}), данные кэшей приложений (\code{cache/}) и др. 
\end{itemize}

\newpage

\section{Типы файлов}

\subsection{Обычные файлы}

К обычным файлам относятся текстовые файлы, изображения, архивы и другие. В утилите \code{ls} обозначается <<\code{-}>>:
\lstinputlisting{1_file_types/file}

\subsection{Каталоги}

Каталоги -- это файлы, в качестве данных которых выступают списки других файлов и каталогов. В утилите \code{ls} обозначается <<\code{d}>>:
\lstinputlisting[deletekeywords={test}]{1_file_types/directory}

\subsection{Символьные ссылки}

Символьная ссылка — это файл в данных которого, содержится указание на адрес другого файла по его имени (но не индексному дескриптору). В утилите \code{ls} обозначается <<\code{l}>>:
\lstinputlisting{1_file_types/symbolic}

\subsection{Файлы устройств}

Файлы устройств -- это файлы, предназначенные для обращения к аппаратному обеспечению компьютера (дискам, принтерам, терминалам и др.). К символьным устройствам обращение происходит последовательно (терминал).
Считывание и запись информации на блочные устройства происходит блоками определенного размера в произвольном порядке (жесткий диск). В утилите \code{ls} обозначаются как <<\code{c}>> и <<\code{d}>> соответственно:
\lstinputlisting[lastline=15]{1_file_types/character}
\lstinputlisting{1_file_types/block}

\subsection{Именованные каналы}

Именованные каналы -- это файлы, позволяющие настроить связь между двумя процессами перенаправив вывод одного процесса на вход другого. Именованный канал позволяет различным процессам обмениваться данными, даже если программы, выполняющиеся в этих процессах, изначально не были написаны для взаимодействия с другими программами. В утилите \code{ls} обозначается <<\code{p}>>:
\lstinputlisting{1_file_types/pipe}

\subsection{Сокеты}

Файлы сокетов -- это файлы, обеспечивающие прямую связь между двумя процессами. Помимо обмена данными, сокеты позволяют обмениваться файловыми дескрипторами. В утилите \code{ls} обозначается <<\code{s}>>:
\lstinputlisting{1_file_types/socket}

\subsection{Поиск всех типов файлов}

Для поиска всех изученных типов файлов был написан скрипт, который находит по одному файлу каждого типа и записывает информацию о нем в файл, передаваемый первым аргументом.
\lstinputlisting[caption=\code{find\_ftypes.sh}]{1_file_types/find_ftypes.sh}

Результат выполнения скрипта:
\lstinputlisting{1_file_types/find_ftypes}

\section{Ссылки}

Файлы и директории располагаются на устройстве хранения в виде набора блоков. Информация о файле (такая, как владелец файла, время последнего обращения к файлу, размер файла, права на чтение или запись, является ли элемент файлом или директорией) хранится в индексном дескрипторе \code{inode}. Номер \code{inode}, известный также как порядковый номер файла, является уникальным в пределах отдельной файловой системы. Запись каталога содержит имя файла (или директории), а также указатель на дескриптор inode, в котором хранится информация об этом файле (или директории).

Ссылки -- это просто дополнительные записи каталога, позволяющие обращаться к файлам или директориям по нескольким именам. В Linux существует два типа ссылок на файлы -- \textbf{жесткие} и \textbf{символьные} ссылки. 

\subsection{Жесткие ссылки}

Жесткие ссылки реализованы на более низком уровне файловой системы, чем символьные. Файл размещен только в определенном месте жесткого диска, но на это место могут ссылаться несколько ссылок из файловой системы. Каждая из ссылок -- это отдельный файл, но ведут они к одному участку жесткого диска. Ключевые особенности:
\begin{itemize}
	\item Работают только в пределах одной файловой системы;
	\item Нельзя ссылаться на каталоги;
	\item Имеют ту же информацию \code{inode} и набор разрешений что и у исходного файла;
	\item Разрешения на ссылку изменяться при изменении разрешений файла;
	\item Можно перемещать, переименовывать и удалять файл без вреда жесткой ссылке.
\end{itemize}

Для создание жестких ссылок используется команда \code{ln}. Чтобы увидеть \code{Inode} созданных файлов используется команда \code{ls -li}:
\lstinputlisting{2_hardlinks/create}

\subsection{Поиск жестких ссылок на файл}

Для поиска всех жестких ссылок на был написан скрипт. Первым параметром является название файла, а вторым -- опционально задаваемый каталог, внутри которого необходимо произвести рекурсивный поиск (при отсутствии второго аргумента поиск ведется внутри текущей директории).
\lstinputlisting[caption=\code{find\_hardlinks.sh}]{2_hardlinks/find_hardlinks.sh}

Результат выполнения скрипта:
\lstinputlisting{2_hardlinks/find_hardlinks}

\subsection{Изменение количества жестких ссылок для директории}

Для директории невозможно создать жесткую ссылку при помощи команды \code{ln}, так как они бы позволили создавать циклы, не позволяли бы однозначно определить родительский каталог и др. Тем не менее, при создании любого каталога, на него уже существует две жесткие ссылки: ссылка на каталог из родительской директории и неявная ссылка <<\code{.}>> в самом каталоге. Из листинга видно, что у \code{folder} в родительском каталоге и у \code{.} в самом каталоге одинаковые inode.
\lstinputlisting[lastline=7]{2_hardlinks/directory}

Чтобы увеличить число ссылок на директорию, можно создать поддиректорию. Внутри поддиректории неявно появится каталог \code{..}, ссылающийся на родительскую директорию.
\lstinputlisting[firstline=9]{2_hardlinks/directory}

Таким образом, при создании подкаталога, число жестких ссылок на директорию увеличивается на 1.

\subsection{Символические ссылки}

Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка. Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет. Ключевые особенности:
\begin{itemize}
	\item Могут ссылаться на файлы и каталоги;
	\item Можно ссылаться на другие разделы диска;
	\item Права доступа и номер \code{inode} отличаются от исходного файла;
	\item После удаления, перемещения или переименования файла становятся недействительными;
	\item При изменении прав доступа для исходного файла, права на ссылку останутся неизменными.
\end{itemize}

Для создания символьных ссылок используется команда \code{ln -s}:
\lstinputlisting{3_symbolic_links/create}

\subsection{Поиск символических ссылок на файл}

Для поиска символических ссылок на файл был написан скрипт. Первым параметром является название файла, а вторым -- опционально задаваемый каталог, внутри которого необходимо произвести рекурсивный поиск (при отсутствии второго аргумента поиск ведется внутри текущей директории).
\lstinputlisting[caption=\code{find\_symblinks.sh}]{3_symbolic_links/find_symblinks.sh}

Результат выполнения скрипта:
\lstinputlisting{3_symbolic_links/find_symblinks}

\section{Утилиты работы с файлами}

\subsection{Утилита \code{find}}

\code{find} -- это одна из наиболее важных и часто используемых утилит системы Linux. Это команда для поиска файлов и каталогов на основе специальных условий. Ее можно использовать для поиска файлов по разрешениям (\code{-perm}), владельцам (\code{-user}), группам (\code{-group}), типу (\code{-type}), размеру (\code{-size}) и другим подобным критериям. Кроме того, с найденными файлами можно сразу же выполнять необходимые действия.

Для выполнения произвольных команд для найденных файлов используется опция \code{-exec}. Например, выполнить \code{ls -i} для получения номера \code{inode} каждого файла в текущей директории:
\lstinputlisting{5_find/exec_ls}

Утилите \code{find} можно задать тип искомых файлов. Например, можно найти в текущей директории только символические ссылки и получить более подробную информацию о них с помощью вложенной команды \code{file}.
\lstinputlisting{5_find/links}

\subsection{Утилиты \code{od} и \code{hd}}

Команда \code{od} выдает на стандартный вывод файл в одном или нескольких форматах в соответствии с указанными опциями. 

Форматы задаются следующим образом:
\begin{itemize}
	\item \code{c} -- печатные символы;
	\item \code{o} -- восьмеричные числа;
	\item \code{x} -- шестнадцатеричные числа;
	\item \code{u} -- беззнаковые целые числа;
	\item \code{d} -- знаковые целые числа.
\end{itemize}

При отсутствии опций используется восьмеричный форма.
\lstinputlisting[lastline=6]{6_od/od}

При попытки применить команду к каталогу была получена ошибка:
\lstinputlisting[firstline=7]{6_od/od}

Команда \code{hd} также может вывести содержимое файла в различных форматах:
\lstinputlisting{6_od/hd}

\section{Изменение размера каталога в зависимости от числа файлов}

Для изменения размера каталога был написан скрипт, генерирующий заданное количество файлов. Число генерируемых файлов передается первым параметров. После создания очередного файла с помощью команды \code{ls -l} извлекается текущий размер каталога и сравнивается с размером на предыдущей итерации. Если размер отличается, то выводится шаг и размер каталога.
\lstinputlisting[caption=\code{generate.sh}]{4_dir/generate.sh}

Результат выполнения скрипта при генерации 2000 файлов:
\lstinputlisting{4_dir/generate}

Видно, что размер файла увеличивается кратно 4096 байтам, что равно размеру блока в файловой системе \code{ext4}. 

Однако определить максимальное число записей в каталоге с помощью данной утилиты невозможно, так как файловая система \code{ext4}, используемая на данном компьютере, не имеет ограничения на количество файлов внутри одного каталога (в то время как, например, файловая система \code{FAT32} имеет ограничение в 65535 файлов). Количество файлов фактически ограничено размером всей файловой системы.

\section{Права владения и доступа}

\subsection{Файлы \code{/etc/passwd} и \code{/etc/shadow}}

Файл \code{/etc/passwd} содержит список пользователей, которые известны системе. В процессе регистрации пользователя система обращается к этому файлу в поисках идентификатора пользователя и его домашнего каталога. Каждая строка файла описывает одного пользователя и  содержит семь полей, разделенных двоеточиями:
\begin{enumerate}
	\item Регистрационное имя;
	\item Зашифрованный пароль или <<заполнитель>> пароля;
	\item Идентификатор пользователя;
	\item Идентификатор группы по умолчанию;
	\item Поле персональных данных;
	\item Домашний каталог;
	\item Командный интерпретатор.
\end{enumerate}

Примеры строк, хранящихся в \code{/etc/passwd}:
\lstinputlisting{7_access/passwd}

Файл \code{/etc/shadow} доступен для чтения только пользователю root и предназначен для хранения зашифрованных паролей. В нем также содержится учетная информация, которая отсутствует в файле \code{/etc/passwd}. При использовании скрытых паролей соответствующие поля в файле \code{/etc/passwd} всегда содержат символ «\code{х}». Каждая строка состоит из 9 полей, разделенных двоеточиями:
\begin{enumerate}
	\item Регистрационное имя;
	\item Зашифрованный пароль;
	\item Дата последнего изменения пароля;
	\item Минимальное число дней между изменениями пароля;
	\item Максимальное число дней между изменениями пароля;
	\item Количество дней до истечения срока действия пароля, когда выдается предупреждение;
	\item Количество дней по истечении срока действия пароля, когда учетная запись отключается;
	\item Срок действия учетной записи;
	\item Зарезервированное поле, которое в настоящее время всегда пустое.
\end{enumerate}

Пример записи о пользователе в \code{/etc/shadow}:
\lstinputlisting{7_access/shadow}

\subsection{Права владения}

Файлы в UNIX имеют двух владельцев: пользователя и группу. Пользователь-владелец может не являться членом группы-владельца. Владельцем-пользователем вновь созданного файла является пользователь, создавший файл. Права владения отображаются в третьей и четвертой колонке при выполнении команды \code{ls -l}:
\lstinputlisting[lastline=3]{7_access/chown}

Для изменения владельца используется команда \code{chown [user][:group]}. Например, можно сменить владельца-пользователя и владельца-группу на \code{root}:
\lstinputlisting[firstline=4]{7_access/chown}

\subsection{Права доступа}

В операционной системе UNIX существуют три базовых класса доступа к файлу, в каждом из которых установлены соответствующие права доступа:
\begin{itemize}
	\item User access (\code{u}) -- для пользователя-владельца файла;
	\item Group access (\code{g}) -- для членов группы, являющейся владельцем файла;
	\item Other access (\code{о}) -- для остальных пользователей (кроме root).
\end{itemize}

ОС UNIX поддерживает три типа прав доступа для каждого класса: 
\begin{itemize}
	\item на чтение (Read, \code{г});
	\item на запись (Write, \code{w});
	\item на выполнение (eXecute, \code{х}).
\end{itemize}

Права доступа отображаются в первой колонке при выполнении команды \code{ls -l} (кроме первого символа):
\lstinputlisting{7_access/ls}

Права доступа могут быть изменены только владельцем файла или root с помощью команды \code{chmod [uga][-+][xrw]}. Например можно дать право на запись членам группы владельца:
\lstinputlisting[lastline=7]{7_access/chmod}

Дать право на выполнение всем трем группам:
\lstinputlisting[firstline=8, lastline=11]{7_access/chmod}

Забрать право на выполнение у остальных пользователей:
\lstinputlisting[firstline=12]{7_access/chmod}

Сменить владельца и группу владельца файла:
\lstinputlisting{7_access/chown}

Операционная система производит проверку прав доступа при создании, открытии (для чтения или записи), запуске на выполнение или удалении файла в следующей последовательности:
\begin{itemize}
	\item Разрешена ли операция для суперпользователя;
	\item Разрешена ли операция для пользователя-владельца;
	\item Разрешена ли операция для члена группы-владельца;
	\item Разрешена ли операция для прочих пользователей.
\end{itemize}

Если пользователь является владельцем, то доступ определяется исключительно из прав пользователя-владельца, а остальные права даже не проверяются:
\lstinputlisting{7_access/seq}

\subsection{Атрибуты \code{SUID} и \code{SGID}}

Существуют другие атрибуты, изменяющие стандартное выполнение программ. Например, Set UID/SUID; Set GID/SGID (\code{s}) установают UID или GID процесса при выполнении.

Атрибуты \code{SUID} и \code{SGID} позволяют изменить права пользователя при запуске на выполнение файла, имеющего эти атрибуты. При этом привилегии будут изменены (обычно расширены) лишь на время выполнения и только в отношении этой программы.

Обычно запускаемая программа получает права доступа к системным ресурсам на основе прав доступа пользователя, запустившего программу. Установка флагов \code{SUID} и \code{SGID} изменяет это правило, назначая права доступа исходя из прав доступа владельца файла. Таким образом, запущенный исполняемый файл, которым владеет суперпользователь, получает неограниченные права доступа к системным ресурсам, независимо от того, кто его запустил.

Примером файла с таким атрибутом является утилита \code{passwd(1)}, позволяющая пользователю поменять пароль:
\lstinputlisting{7_access/suid}

Изменение пароля должно приводить к изменению файлов \code{/etc/passwd} и \code{/etc/shadow}. Но вместо того, чтобы давать возможность записи в эти файлы всем пользователям, программа \code{/usr/bin/passwd}, владельцем которой является \code{root}, содержит флаг \code{SUID}. Таким образом, любой пользователь, запускающий утилиту \code{passwd}, получает на время выполнения права суперпользователя.

\subsection{Программа-шлюз}

Для доступа к файлу другого пользователя при отсутствии прав на чтение информации из этого файла была разработана <<программа-шлюз>>. 

Рассмотрим файл \code{root\_file}, права на чтение и запись в который есть только у другого пользователя (\code{root}).
\lstinputlisting{9_gateway/before}

Разработаем программу на языке \code{C}, которая будет вызывать команду \code{cat root\_file}:
\lstinputlisting[language=C,caption=\code{gateway.c}]{9_gateway/gateway.c}

Скомпилируем программу, сделаем владельцем файла пользователя \code{root}, установим флаг \code{SUID} и запустим \code{gateway}:
\lstinputlisting{9_gateway/after}

Видно, что с помощью флага \code{SUID} получилось расширить права текущего пользователя до владельца файла (\code{root}) и увидеть содержимое файла \code{root\_file}.

\section{Утилиты получения информации о ФС}

\subsection{Утилита \code{df}}

Утилита \code{df} (disk free) выводит список всех файловых систем по именам устройств с указанием размера, показывает точки монтирования и количество свободного/занятого пространства.
\lstinputlisting{8_fs/df}

В выводе отображается информация как о реальных (\code{vfat}, \code{ext4}), так и виртуальных файловых системах (\code{devfs}, \code{tmpfs}, \code{squashfs}). Для вывода данных только о реальных файловых системах используется команда:
\lstinputlisting{8_fs/df_real}

\subsection{Файл \code{/etc/fstab}}

Файл \code{/etc/fstab} -- это текстовый файл, который содержит информацию о различных файловых системах и устройствах хранения информации в компьютере. Это всего лишь один файл, определяющий, как диск и/или раздел будут использоваться и как будут встроены в остальную систему. 

Этот файл можно открыть в любом текстовом редакторе, но редактировать его возможно только от имени суперпользователя, т.к. файл является важной, неотъемлемой частью системы. При загрузке операционной системы, \code{fsck} считывает список монтируемых файловых систем из файла \code{/etc/fstab}.

\lstinputlisting{8_fs/fstab}

Строки файла содержат следующие поля:
\begin{itemize}
	\item Что монтируем -- некоторое блочное устройство, которое должно быть примонтировано;
	\item Куда монтируем -- точка монтирования - путь в корневой файловой системе к каталогу в который будет смонтировано устройство;
	\item Тип файловой системы монтируемого раздела;
	\item Опции монтирования файловой системы;
	\item Индикатор необходимости делать резервную копию (как правило не используется и равно 0);
	\item Порядок проверки раздела (0 -- не проверять, 1 -- устанавливается для корня, 2 -- для остальных разделов).
\end{itemize}

\subsection{Файл \code{/etc/mtab}}

Файл \code{/etc/mtab} содержит список реально установленных на компьютере файловых систем.
\lstinputlisting[linerange={1-11,34-50}]{8_fs/mtab}

Формат файла схож с \code{/etc/fstab} и содержит 6 столбцов, разделенных пробелом:
\begin{enumerate}
	\item файл устройства;
	\item точка монтирования;
	\item тип файловой системы;
	\item параметры монтирования файловой системы разделяемые запятой;
	\item флаг программы dump;
	\item флаг программы fsck.
\end{enumerate}

Присоединим к ноутбуку USB-flash накопитель. В файле \code{/etc/mtab} в конец добавилась строка:
\lstinputlisting{8_fs/mtab_flash}

Из строки видно, что файл устройства -- \code{/dev/sdb1}, точка монтирования -- \code{/media/vaddya/USB 040Strick}, тип файловой системы -- \code{fuseblk} (\code{ntfs} раздел, FUSE -- file system in userspace), возможно чтение и запись, запрещено выставление бита SUID, файлы устройств не интерпретируются, обновление inode access time только если предыдущие было раньше, ID пользователя и группы, размер блока равен 4096 байт, флаги dump и fsck сброшены.

\subsection{Утилита \code{file}}

Утилита \code{file} сканирует начало файла и пытается определить его тип. Сначала выполняется проверка на уровне файловой системы: является ли файлом пустым или относится к специальному типу (ссылки, сокеты и др.). Если это текстовый файл (ASCII), \code{file} пытается определить его синтаксис (текст, программа на языке \code{С} и др.). Если это бинарный файл, то классификация ведется по так называемому <<магическому числу>>, определения которого находятся в файлах \code{/usr/share/misc/magic.mgc} и \code{/etc/magic} в бинарном формате.

\lstinputlisting{8_fs/file}

Для добавления своего формата файла была добавлена строка в файл \code{/etc/magic}, включающая 
\begin{itemize}
	\item информацию об отступе от начала файла;
	\item тип, который считывается по указанному отступу;
	\item ожидаемое значение по указанному отступу;
	\item описание данного формата.
\end{itemize}
\lstinputlisting{10_magic/magic}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item изучены иерархия файловой системы и основные каталоги корневого каталога;
	\item рассмотрены все типы файлов в ОС Unix: обычные файлы, каталоги, символьные ссылки, файлы устройств, именованные каналы и сокеты;
	\item изучено создание и поиск жестких и символических ссылок;
	\item исследованы права владения и доступа к файлам, включая специальные атрибуты \code{SUID} и \code{SGID};
	\item рассмотрены основные утилиты для работы с файлами и файловыми системами.
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Робачевский А. Операционная система UNIX [Текст] -- 2010.
	\item Уорд Б. Внутреннее устройство Linux [Текст] -- 2016.
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item \url{https://losst.ru/tipy-fajlov-v-linux} -- Типы файлов в Linux.
	\item Символические и жесткие ссылки Linux. [Электронный ресурс]:\\
		\url{https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux}
	\item Иерархия каталогов и файловых систем в Linux. [Электронный ресурс]:\\
		\url{http://linux.yaroslavl.ru/docs/conf/fs/fhs-full.html}
	\item Filesystem Hierarchy Standard. [Электронный ресурс]:\\
		\url{https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard}
	\item Format of the /etc/magic file. [Электронный ресурс]:\\
		\url{https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxa500/mgc.htm}
\end{enumerate}

%\newpage
%
%\section*{Дополнения к отчету}
%
%\subsection*{Изменение количества жестких ссылок для директории}
%
%Для директории невозможно создать жесткую ссылку при помощи команды \code{ln}, так как они бы позволили создавать циклы, не позволяли бы однозначно определить родительский каталог и др. Тем не менее, при создании любого каталога, на него уже существует две жесткие ссылки: ссылка на каталог из родительской директории и неявная ссылка <<\code{.}>> в самом каталоге. Из листинга видно, что у \code{folder} в родительском каталоге и у \code{.} в самом каталоге одинаковые inode.
%\lstinputlisting[lastline=7]{2_hardlinks/directory}
%
%Чтобы увеличить число ссылок на директорию, можно создать поддиректорию. Внутри поддиректории неявно появится каталог \code{..}, ссылающийся на родительскую директорию.
%\lstinputlisting[firstline=9]{2_hardlinks/directory}
%
%Таким образом, при создании подкаталога, число жестких ссылок на директорию увеличивается на 1.
%
%\subsection*{Изменение размера каталога в зависимости от числа файлов}
%
%Для изменения размера каталога был написан скрипт, генерирующий заданное количество файлов. Число генерируемых файлов передается первым параметров. После создания очередного файла с помощью команды \code{ls -l} извлекается текущий размер каталога и сравнивается с размером на предыдущей итерации. Если размер отличается, то выводится шаг и размер каталога.
%\lstinputlisting[caption=\code{generate.sh}]{4_dir/generate.sh}
%
%Результат выполнения скрипта при генерации 2000 файлов:
%\lstinputlisting{4_dir/generate}
%
%Видно, что размер файла увеличивается кратно 4096 байтам, что равно размеру блока в файловой системе \code{ext4}. 
%
%\subsection*{Файл \code{/etc/mtab}}
%
%Файл \code{/etc/mtab} содержит список реально установленных на компьютере файловых систем.
%\lstinputlisting[linerange={1-11,34-50}]{8_fs/mtab}
%
%Формат файла схож с \code{/etc/fstab} и содержит 6 столбцов, разделенных пробелом:
%\begin{enumerate}
%	\item файл устройства;
%	\item точка монтирования;
%	\item тип файловой системы;
%	\item параметры монтирования файловой системы разделяемые запятой;
%	\item флаг программы dump;
%	\item флаг программы fsck.
%\end{enumerate}
%
%Присоединим к ноутбуку USB-flash накопитель. В файле \code{/etc/mtab} в конец добавилась строка:
%\lstinputlisting{8_fs/mtab_flash}
%
%Из строки видно, что файл устройства -- \code{/dev/sdb1}, точка монтирования -- \code{/media/vaddya/USB 040Strick}, тип файловой системы -- \code{fuseblk} (\code{ntfs} раздел, FUSE -- file system in userspace), возможно чтение и запись, запрещено выставление бита SUID, файлы устройств не интерпретируются, обновление inode access time только если предыдущие было раньше, ID пользователя и группы, размер блока равен 4096 байт, флаги dump и fsck сброшены.

\end{document}
