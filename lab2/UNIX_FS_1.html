<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=koi8-r">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="UnixFS.files/filelist.xml">
<title>ose-3</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Igor</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Igor</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>5</o:TotalTime>
  <o:Created>2006-12-31T23:26:00Z</o:Created>
  <o:LastSaved>2006-12-31T23:26:00Z</o:LastSaved>
  <o:Pages>4</o:Pages>
  <o:Words>1783</o:Words>
  <o:Characters>10164</o:Characters>
  <o:Company>Home</o:Company>
  <o:Lines>84</o:Lines>
  <o:Paragraphs>23</o:Paragraphs>
  <o:CharactersWithSpaces>11924</o:CharactersWithSpaces>
  <o:Version>10.2625</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:SpellingState>Clean</w:SpellingState>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->
<meta name=Author content="Igor Malyshev">
</head>

<body lang=RU style='tab-interval:35.4pt'>

<div class=Section1>

<p class=MsoNormal align=center style='text-align:center'>Лабораторная работа
&#8470; 2 </p>

<p align=center style='text-align:center'>по дисциплине &quot;Операционные
системы и среды&quot; </p>

<p align=center style='text-align:center'><b>ФАЙЛОВАЯ СИСТЕМА ОС UNIX</b></p>

<p>Цель работы: изучение принципов организации файловой системы ОС UNIX на
примере <span class=SpellE>Linux</span>. </p>

<p align=center style='text-align:center'><b>Программа работы</b></p>

<p><b><i>Введение</i></b> </p>

<p>В семействе операционных систем UNIX используется несколько типов файловых
систем. Одной из наиболее распространенных является разработанная для UNIX <span
class=SpellE>System</span> V файловая система s5 (system5, s51k <span
class=SpellE>b</span> и.п.) Она характеризуется большой надежностью. Другая
(BSD) отличается высоким быстродействием. В настоящее время появились новые
типы файловых систем, отличающиеся повышенной надежностью, устойчивостью к
программных сбоям, способностью работать в распределенной среде. </p>

<p>Файловые системы имеют иерархическую структуру, организуемую с помощью
специальных файлов - каталогов. Файловая система физически располагается на так
называемых блочных устройствах - носителе информации, хранение и обмен данными
с которым производится <span class=SpellE>поблочно</span>, часто порциями по
1Kb. Само устройство не знает, что за файловая система находится на нем, оно
позволяет работать с собой просто как с массивом блоков. Структуру файловой
системы поддерживает ядро. </p>

<p>В UNIX не используется расширение имен для определения типов файлов
(текстового, бинарного и т.п.). Существует один, универсальный тип
&laquo;дискового&raquo; файла. В UNIX сняты ограничения на длину имени файла и
постфикса (или суффикса). </p>

<p>В UNIX имеется три вида файлов, доступ к которым идентичен: <br>
- обычные дисковые файлы; <br>
- каталоги; <br>
- специальные файлы. </p>

<p><b><i>I. Иерархия каталогов</i></b> </p>

<p>Файлы и каталоги представляют логическую структуру файловой системы UNIX,
которая является древовидной. Логическая структура файловой системы UNIX
всегда, вне зависимости от количества физических дисковых устройств и
количества разделов (<span class=SpellE>partition</span>) на каждом из них,
имеет только один корень, который всегда обозначается как / и называется
корневым каталогом файловой системы. </p>

<p>Исследуйте структуру файловой системы на вашем компьютере и назначение
содержимого корневого каталога. Определите размер блока. </p>

<p>В UNIX возможна работа с несколькими файловыми системами одновременно. При
этом создается видимость одной большой иерархии с корневым каталогом /.
Определите связь логической структуры файловой системы и физической структурой,
используя команду <span class=SpellE>df</span>. (воспользуйтесь <span
class=SpellE>man</span>). </p>

<p><b><i>II. Невидимые символы</i></b> </p>

<p>Создайте файл <span class=SpellE>prog.c</span> (если такового уже&nbsp;
нет), содержимым которого является программа на С. <br>
Применив&nbsp; команду <span class=SpellE>ls</span> , определите владельца и
группу файла, права доступа, размер файла, время последнего изменения. <br>
С помощью команды <span class=SpellE>od</span> (<span class=SpellE>octal</span>
<span class=SpellE>dump</span> - восьмеричный дамп) выведите побайтную
распечатку <span class=SpellE>prog.c</span> . Исследуйте&nbsp; различные&nbsp;
варианты: <span class=SpellE>od</span> , <span class=SpellE>od</span> -c , <span
class=SpellE>od</span> -<span class=SpellE>b</span> , <span class=SpellE>od</span>
-<span class=SpellE>cb</span>&nbsp; .&nbsp; Прокомментируйте результат. Как
изображается символ перевода строки пробел, табуляция? </p>

<p><b><i>III. Ввод-вывод для файлов-терминалов</i></b> </p>

<p>Определите с помощью <span class=SpellE>tty</span> полное имя вашего
файла-терминала. Выведите какую-нибудь информацию посредством <span
class=SpellE>cat</span> или <span class=SpellE>echo</span>, переназначив
стандартный вывод на этот файл. Повторите эту операцию, переназначив вывод на
другой терминал (соседа). Что происходит? </p>

<p>При чтении с терминала ввод буферизуется не <span class=SpellE>поблочно</span>
(как при работе с дисками), а построчно (это не относится к экранным программам
типа редактора, где ввод происходит побайтно без буферизации). Каждая операция
чтения заканчивается после посылки с клавиатуры символа перевода строки <span
class=SpellE>NewLine</span>. Программа получает всю набранную строку вместе с
завершающим <span class=SpellE>NewLine</span>. </p>

<p>Существуют специальные переназначаемые символы, предназначенные для
&laquo;досрочного&raquo; завершения ввода. Как правило, одним из них
назначается <span class=SpellE>Ctrl+D</span>. </p>

<p>Запустите <span class=SpellE>cat</span> без аргументов, переназначив ее
вывод на какой-нибудь файл. Введите насколько строк. Окончите ввод посредством <span
class=SpellE>Ctrl+D</span>. С помощью <span class=SpellE>od</span> исследуйте,
записался ли <span class=SpellE>Ctrl+D</span> в файл. </p>

<p>Запустите <span class=SpellE>cat</span>, наберите несколько символов без <span
class=SpellE>NewLine</span> и завершите ввод <span class=SpellE>Ctrl+D</span>.
Что происходит? Появляется ли приглашение <span class=SpellE>shell</span>? Что
необходимо сделать, чтобы оно появилось? </p>

<p>Как бы вы сформулировали правила, по которым система определяет, что
файл-терминал &quot;кончился&quot;? </p>

<p><b><i>IV. Содержимое файлов</i></b> </p>

<p>Команда <span class=SpellE>file</span> проводит серию тестов, пытаясь&nbsp;
классифицировать файлы, указанные в командной строке. Если обычный файл
содержит текст в кодах ASCII, команда пытается по первому блоку угадать язык
программирования. В том случае, когда обычный файл содержит двоичную
информацию, <span class=SpellE>file</span> выясняет, является ли он объектным,
библиотечным, выполнимым или каким-то иным. При запуске файла на исполнение
(системный вызов <span class=SpellE>exec</span>) ОС проверяет его первой
двухбайтное слово. Если оно содержит специальной значение (&laquo;магическое
число&raquo;), ОС считает такой файл содержащим машинные коды и запускает эту
программу. </p>

<p>Исследуйте с помощью этой команды различные файлы: /<span class=SpellE>bin</span>
, . , <span class=SpellE>prog.c</span> , какой-либо ваш текстовый файл,
объектный, исполняемый (типа <span class=SpellE>a.out</span>) , /bin/sh ,
/lib/libc.a , /<span class=SpellE>etc</span>/<span class=SpellE>passwd</span>,
и т.п. Прокомментируйте полученную информацию. </p>

<p>С помощью <span class=SpellE>tail</span> запишите хвост /<span class=SpellE>bin</span>/<span
class=SpellE>sh</span> в файл <span class=SpellE>hhh</span>. Исследуйте его с
помощью <span class=SpellE>file</span> . Что сделает команда <span
class=SpellE>file</span> , если не сумеет распознать вид файла? </p>

<p>С помощью <span class=SpellE>od</span> определите магическое число (первые
два байта) <span class=SpellE>executable</span> файлов. (Используйте пословный
вывод <span class=SpellE>od</span>&nbsp; (<span class=SpellE>od</span> , <span
class=SpellE>od</span> -<span class=SpellE>d</span> ). Сравните полученные
результаты с содержимым файла /<span class=SpellE>etc</span>/<span
class=SpellE>magic</span>, содержащим магические числа системы. </p>

<p>Скопируйте <span class=SpellE>prog.c</span> в файл с другим именем, не
оканчивающимся на соответствующий суффикс. Что скажет <span class=SpellE>file</span>
о нем? </p>

<p><b><i>V. Права доступа</i></b> </p>

<p><i>5.1. Права доступа процессов к файлам</i> </p>

<p>Какие категории пользователей выделены в UNIX для определения прав доступа?
Какие права доступа могут быть предоставлены при обращении к обычному файлу? </p>

<p>Файл по умолчанию получает идентификаторы владельца и группы того процесса,
который его создал. Владелец и группа процессов наследуются при порождении. <span
class=SpellE>Суперпользовательский</span> процесс может изменить себе владельца
и группы (обратное, однако, уже невозможно). </p>

<p>Всеобщий предок (процесс с номером 1) имеет идентификатор пользователя,
равный 0.&nbsp; Также <span class=SpellE>суперпользовательскими</span> являются
процессы, выдающие на терминал <span class=SpellE>login</span>: . После
успешного входа в систему они замещают себя на <span class=SpellE>shell</span>,
установив перед этим владельца и группу в соответствии с введенным паролем. </p>

<p>Определите права доступа&nbsp; к&nbsp; своему&nbsp;
&quot;домашнему&quot;&nbsp; каталогу (соответствующему переменной окружения
HOME ) ('<span class=SpellE>ls</span>&nbsp; -<span class=SpellE>ld</span>&nbsp;
.'). </p>

<p>Обеспечьте посредством команды <span class=SpellE>chmod</span> все права
себе, возможность чтения и поиска для вашей группы и никаких прав остальным.
Прокомментируйте ваши действия. Укажите различные варианты задания прав доступа
к команде <span class=SpellE>chmod</span>. </p>

<p><i>5.2 Файл паролей /<span class=SpellE>etc</span>/<span class=SpellE>passwd</span></i>
</p>

<p>В системе существует файл /<span class=SpellE>etc</span>/<span class=SpellE>passwd</span>
- файл паролей, по содержимому которого определяется соответствие между
номерами и именами владельцев. При работе ОС не знает имени владельца, нет
имени и в описателе файла на диска. Информационные команды получают номер,
обратившись к /<span class=SpellE>etc</span>/<span class=SpellE>passwd</span>. </p>

<p>Определите структуру файла паролей и назначение его полей, обратившись к
файлу /<span class=SpellE>etc</span>/<span class=SpellE>passwd</span> и
руководству <span class=SpellE>man</span>. </p>

<p>Группы тоже имеют имена, информация об этом содержится в файле /<span
class=SpellE>etc</span>/<span class=SpellE>passwg</span>. Могут ли несколько
пользователей входить в одну группу? Определите структуру файла /<span
class=SpellE>etc</span>/<span class=SpellE>passwg</span> назначение его полей. </p>

<p>Посредством команды <span class=SpellE>id</span> определите имена&nbsp;
и&nbsp; идентификаторы владельца и группы вашего текущего процесса (<span
class=SpellE>shell`а</span>). </p>

<p><i>5.3. Переустановка идентификатора владельца процесса</i> </p>

<p>В слове защиты файла предусмотрены специальные биты, которые позволяют
изменить идентификаторы пользователя и группы. Первоначальные идентификаторы,
связанные с процессом, называются реальными, а идентификаторы, полученным им
после выполнения системного вызова <span class=SpellE>exec</span> -
эффективными. Первоначально они всегда совпадают, но если в коде защиты файла
предусмотрена смена идентификатора, то после загрузки исполняемого файла по <span
class=SpellE>exec</span> реальные идентификаторы процесса изменяются на
идентификаторы владельца (или группы) исполняемого файла, т.е. становятся
эффективными. </p>

<p>По каким идентификаторам, реальным или эффективным, определяются права
доступа процесса? </p>

<p>С помощью <span class=SpellE>ls</span> определите права доступа к файлу /<span
class=SpellE>etc</span>/<span class=SpellE>passwd</span>, а также права доступа
к файлу /<span class=SpellE>bin</span>/<span class=SpellE>passwd</span>
(программа для смены пароля). Скопируйте к себе /<span class=SpellE>bin</span>/<span
class=SpellE>passwd</span> с тем же именем. Проверьте результат, в т.ч.
владельца копии. Сравните оба файла командой <span class=SpellE>cmp</span>.
Удалите свою копию <span class=SpellE>passwd</span>. </p>

<p>Попробуйте изменить себе пароль с помощью собственной копии <span
class=SpellE>passwd</span>. Что получилось? Почему? </p>

<p>Создайте С-программу, которая выводит данные в файл. С помощью системных
вызовов <span class=SpellE>getuid</span>(), <span class=SpellE>getgid</span>(),
<span class=SpellE>getegid</span>() заносите в файл информацию о реальных и
эффективных идентификаторах пользователя. Создайте исполняемый файл. Выполните
программу сами. С помощью назначения соответствующих прав доступа обеспечьте
режим обращения к файлу с данными только через вашу программу.
Продемонстрируйте эту возможность, представив в отчете соответствующие
результаты и пояснения. </p>

<p><i>5.4. Права доступа к каталогам</i> </p>

<p>Право на запись в каталог означает возможность создавать и удалять в нем
файлы. Право на чтение позволяет прочесть каталог, а право на выполнение
трактуется как право на поиск. </p>

<p>Определите права доступа к своему &laquo;домашнему&raquo; каталогу.
Обеспечьте посредством команды <span class=SpellE>chmod</span> все права себе,
возможность чтения и поиска для вашей группы и никаких прав остальным. </p>

<p>Для изменения владельца или группы файла предназначены команды <span
class=SpellE>chown</span> и <span class=SpellE>chgrp</span> соответственно (см.
<span class=SpellE>man</span>). Поменяйте владельца какого-нибудь вашего файла
с помощью <span class=SpellE>shown</span>. Сможете ли теперь изменить права
доступа к этому файлу (<span class=SpellE>chmod</span>)? Вернуть владельцем
себя? А удалить его? Почему? </p>

<p><b><i>VI. Содержимое каталогов</i></b> </p>

<p>Файловая система состоит из трех частей: <br>
- <span class=SpellE>Суперблока</span>; <br>
- Области описателей файлов (i-узлов); <br>
- Области для хранения содержимого файлов. </p>

<p>С помощью команды <span class=SpellE>df</span> определите занятое, свободное
и общее пространство на дисках. Что произойдет, если будут задействованы все
i-узлы? </p>

<p>Посредством <span class=SpellE>od</span> прочтите содержимое вашего каталога
как файла (<span class=SpellE>od</span> -<span class=SpellE>cb</span> . ).
Сравните полученную информацию с полным содержимым каталога, выдаваемым
командой <span class=SpellE>ls</span> -a. Осталось ли что-нибудь от удаленных
файлов? Что их отличает от <span class=SpellE>неудаленных</span>? </p>

<p>С помощью ключа -<span class=SpellE>i</span> команды <span class=SpellE>ls</span>
выведите имена файлов&nbsp; вместе с соответствующими номерами описателей.
Сравните вывод с пословным прочтением каталога в десятичной форме ( <span
class=SpellE>od</span> -<span class=SpellE>d</span> ) . </p>

<p>Удалите какой-либо ненужный файл. Проверьте изменения в файле-каталоге.
Создайте новый файл. Проверьте каталог. Куда помещаются новые записи? Что
изменилось бы, если вместо удаления файла вы его переместили в иной каталог (<span
class=SpellE>mv</span>) ? </p>

<p>Как можно интерпретировать&nbsp; сообщаемый&nbsp; <span class=SpellE>ls</span>&nbsp;
-<span class=SpellE>ld</span>&nbsp; &lt;<span class=SpellE>dirname</span>&gt;
размер &lt;<span class=SpellE>dirname</span>&gt; в байтах? Сжимает&nbsp;
ли&nbsp; система&nbsp; каталог&nbsp; после уменьшения в нем числа файлов? Как
узнать, сколько&nbsp; в&nbsp; каталоге &quot;дыр&quot;? </p>

<p>Сравните вывод <span class=SpellE>ls</span> -<span class=SpellE>l</span> <span
class=SpellE>prog.c</span> до и&nbsp; после&nbsp; установления еще одной связи
(<span class=SpellE>линка</span>) с этим файлом посредством команды <span
class=SpellE>ln</span>&nbsp; (&nbsp; <span class=SpellE>ln</span> <span
class=SpellE>prog.c</span> &lt;<span class=SpellE>другое_имя</span>&gt; ).
Что&nbsp; изменилось? Какие номера инд. <br>
<span class=SpellE>дескр-в</span> (<span class=SpellE>ls</span> -<span
class=SpellE>i</span>) соответствуют этим двум именам? Сколько файлов
существует на самом деле? </p>

<p>Найдите в /<span class=SpellE>bin</span> или /<span class=SpellE>usr</span>/<span
class=SpellE>bin</span> редактор <span class=SpellE>vi</span> и определите
количество связей к нему. Сколько байт занимают <span class=SpellE>vi</span> и <span
class=SpellE>ex</span>? </p>

<p>Переименуйте какой-нибудь свой файл (<span class=SpellE>mv</span>).
Изменился ли номер его описателя? Перешлите какой-нибудь ненужный файл в /<span
class=SpellE>tmp</span> (если он доступен). Проверьте номер описателя (<span
class=SpellE>ls</span> -i). Перемещался ли файл на диске? Сделайте там же копию
этого файла (<span class=SpellE>cp</span>), проверьте описатель. Что было бы,
если вместо <span class=SpellE>cp</span> использовалось <span class=SpellE>ln</span>?
Уберите свои следы из /<span class=SpellE>tmp</span>. <br>
Что произойдет с <span class=SpellE>prog.c</span> после <span class=SpellE>после</span>
удаления дополнительной связи к нему? А с содержимым его описателя? </p>

<p>Осуществляет ли <span class=SpellE>shell</span> какую-либо подстановку в
командных строках <span class=SpellE>cd</span> .., <span class=SpellE>ls</span>
./main.c? Сколько связей у вашего файла-каталога с именем '.' ? Сколько их
будет, когда вы создадите (еще один) вложенный каталог? Во всех ли&nbsp;
каталогах&nbsp; имеются имена . и .. ? (<span class=SpellE>ls</span> -a)? </p>

<p><b><i>VII. Специальные файлы</i></b> </p>

<p>Выведите информацию посредством <span class=SpellE>ls</span> -<span
class=SpellE>l</span> и <span class=SpellE>file</span> для следующих файлов: <br>
/<span class=SpellE>dev</span>/<span class=SpellE>tty</span> <br>
/<span class=SpellE>dev</span>/<span class=SpellE>dsk</span>/<span
class=SpellE>fd</span> <br>
/<span class=SpellE>user</span>/<span class=SpellE>spool</span>/<span
class=SpellE>lp</span>/FIFO <br>
В чем отличие в выводе специальных файлов по сравнению с обычными файлами и
каталогами? Какие виды специальных файлов существуют в UNIX? <br>
&nbsp; </p>

</div>

</body>

</html>
