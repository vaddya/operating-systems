\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

Осуществить анализ механизмов обработки аппаратных и программных исключений, доступных в операционной системе Linux.

\section{Программа работы}

\input{workprogram}

\section{Используемое окружение}

\begin{itemize}
	\item ОС: Ubuntu
	\item Версия ОС: 19.10
	\item Процессор: Intel® Core™ i7-8550U CPU @ 1.80GHz × 8
	\item ОЗУ: 16 Гб
	\item Компилятор: g++ (Ubuntu 9.2.1-9ubuntu2) 9.2.1 20191008
	\item Отладчик: GNU gdb (Ubuntu 8.3-0ubuntu1) 8.3
\end{itemize}

\section{Используемые утилиты}

\subsection{GNU gdb}

%TODO про gdb

\subsection{strace}

%TODO про strace

\subsection{ltrace}

%TODO про ltrace

\section{Обработка сигналов}

\subsection{Типы сигналов}

Сигналы в системе UNIX  используются для того, чтобы сообщить процессу о том, что возникло какое-либо событие или необходимо обработать исключительное состояние. 

%TODO табличка сигналов

\subsection{Вспомогательные функции}

Реализуем вспомогательные функции, которые помогут исследовать генерацию и обработку сигналов.

\lstinputlisting[caption=\code{utils.h}]{src/utils/utils.h}

\lstinputlisting[caption=\code{utils.cpp}]{src/utils/utils.cpp}

Рассмотрим реализацию представленных функций:
\begin{itemize}
	\item \code{void generateSigfpe()} -- генерирует сигнал ошибочной арифметической операции \code{SIGFPE}. Для этого выполняется операция деления на ноль.
	\item \code{generateSigill()} -- приводит к генерации сигнала выполнения неправильно сформированной, несуществующей или привилегированной инструкции \code{SIGILL}. Для этого используется функция \code{__buildin_trap()}, которую предоставляет компилятор \code{g++}. Внутри этой функции выполняется несуществующая инструкция для того, чтобы завершить программу ненормально (abnormal exit).
	\item \code{__sighandler_t signalHandler(int sig, __sighandler_t handler)} -- является оберткой над функцией \code{signal} для выставления обработчика \code{handler} для сигнала \code{s}. Сигналы \code{SIGKILL} и \code{SIGSTOP} не могут быть перехвачены или проигнорированы. В качестве обработчика также можно передать \code{SIG_IGN} (игнорирование сигнала) и \code{SIG_DFL} (восстановить обработчик по умолчанию).
	\item \code{__sighandler_t sigactionHandler(int s, __sighandler_t handler)} -- является обёрткой над функцией \code{sigaction} для выставления обработчика \code{handler} для сигнала \code{s}. Функция \code{sigaction} -- это альтернативный способ выставления обработчика для сигнала при помощи одноименной структуры \code{sigaction}. Эта структура имеет следующие важные поля: \code{sa_handler} -- функция-обработчик; \code{sa_mask} -- маска сигналов, которые
	будут блокированы пока выполняется этот обработчик (по умолчанию блокируется и сам полученный сигнал); \code{sa_flags} -- позволяет задать дополнительные действия при обработке сигнала (например, возможность автоматически установить обработчик по умолчанию после первого выполнения обработчика).
	\item \code{void printingHandler(int sig)} -- используется в качестве обработчика в демонстрационных целях. В рамках обработки функция выводит отладочную информацию о полученном сигнале, после чего восстанавливает обработчик по умолчанию.
	\item \code{std::string toString(int sig)} -- вспомогательная функция, которая преобразует номер сигнала в его словесное описание.
\end{itemize}

\subsection{Генерация сигналов}

\subsubsection{\code{SIGFPE}}

Рассмотрим программу генерации сигнала выполнения ошибочной арифметической операции \code{SIGFPE}. Для этого вызовем функцию \code{generateSigfpe}, рассмотренную выше.

\listingwithoutput{sigfpe}

Видно, что программа завершилась с кодом ошибки 136, что соответствует ошибочной арифметической операции (в данном случае, делению на 0).

Запустим программу \code{sigfpe} в отладчике \code{gdb}.

\logs{sigfpe/gdb}

Из строки 13 видно, что произошла арифметическая ошибка и программа получила сигнал \code{SIGFPE}, после чего программа была завершена.

\subsubsection{\code{SIGILL}}

Рассмотрим программу генерации сигнала, генерируемого при попытке выполнить неправильно сформированную, несуществующую или привилегированную инструкцию \code{SIGILL}. Для этого будем использовать функцию \code{generateSigill}.

\listingwithoutput{sigill}

Запустим программу \code{sigill} в отладчике \code{gdb}.

\logs{sigill/gdb}

Из строки 13 видно, что была выполнена неправильная инструкция и программа получила сигнала \code{SIGILL}, после чего программа была завершена.

\subsection{Назначение обработчика сигнала с помощью \code{signal}}

\subsubsection{\code{SIGFPE}}

Рассмотрим программу, в которой будет установлен обработчик для сигнала \code{SIGFPE}. Установленный обработчик будет выводить номер полученного сигнала и возвращать обработчик по умолчанию. Для этого вызовем вспомогательную функцию \code{singalHandler}, передав ей номер нужного сигнала и нужный обработчик.

\listingwithoutput{sigfpe_signal}

Запустим программу \code{sigfpe_signal} в отладчике \code{gdb}.

\logs{sigfpe_signal/gdb}

Видно, что инструкция, вызывающая получение сигнала, была выполнена дважды. В первый раз был выполнен установленный обработчик, который вывел информацию о сигнале (с. 20). Во второй раз уже был вызван обработчик по умолчанию, который завершил выполнение программы (с. 29).

\subsubsection{\code{SIGILL}}

Выполним аналогичные действия с сигналом \code{SIGILL}. Воспользуемся той же вспомогательной функцией \code{signalHandler}.

\listingwithoutput{sigill_signal}

Запустим программу \code{sigill_signal} в отладчике \code{gdb}.

\logs{sigill_signal/gdb}

Видно, что функция \code{__buildin_trap} была вызвана дважды. В первый раз сгенерированный сигнал был обработан \code{printingHandler}, а во второй раз был вызван обработчик по умолчанию, завершивший программу.

\subsection{Назначение обработчика сигнала с помощью \code{sigaction}}

\subsubsection{\code{SIGFPE}}

Функция \code{sigaction} может быть использована вместо \code{signal}, чтобы обеспечить надежную передачу сигнала: если при
возникновении сигнала система будет занята обработкой другого сигнала, то возникший сигнал не будет потерян. Его обработка будет отложена до окончания текущего обработчика и применена после этого.

Воспользуемся функцией \code{sigactionHandler} для того, чтобы выставить обработчик сигнала \code{SIGFPE} через функцию \code{sigaction}.

\listingwithoutput{sigfpe_sigaction}

Вывод отладчика \code{gdb} аналогичен предыдущему разделу, поэтому рассмотрим системные вызовы, которые делает разработанная программа, при помощи утилиты \code{strace}.

\logs{sigfpe_sigaction/strace}

Видно, что программа выполняет системный вызов \code{rt_sigaction} (с. 6). Данный вызов происходит при вызове \code{sigaction}. Функция проверяет и устанавливает signal action для переданного сигнала. Во второй раз \code{rt_sigaction} (c. 12) используется для восстановления обработчика по умолчанию. В конце происходит вызов \code{rt_sigreturn} -- возврат из обработчика и отчистка стек фрейма. Кроме того, восстанавливается маска сигналов процесса, происходит переключение стека, восстанавливается контекст процесса (регистры, флаги процессора), после чего процесс продолжает выполнение с того места, где произошло получение сигнала.

\subsubsection{\code{SIGILL}}

Воспользуемся функцией \code{sigactionHandler} для того, чтобы выставить обработчик сигнала \code{SIGILL} через функцию \code{sigaction}.

\listingwithoutput{sigill_sigaction}

Вывод отладчика \code{gdb} аналогичен предыдущему разделу, поэтому рассмотрим системные вызовы, которые делает разработанная программа, при помощи утилиты \code{strace}.

\logs{sigill_sigaction/strace}

Аналогично выводу \code{strace} при генерации сигнала \code{SIGFPE}, программа дважды вызывает \code{rt_sigaction} для того, чтобы выставить обработчик для сигнала, и единожды \code{rt_sigreturn} для возврата из обработчика.

\section{Исключения языка \code{C++}}

\subsection{Вспомогательные функции}

Реализуем вспомогательные функции, которые помогут исследовать генерацию и обработку исключений в стиле \code{C++}.

\lstinputlisting[caption=\code{exceptions.h}]{src/exceptions/exceptions.h}

\lstinputlisting[caption=\code{exceptions.cpp}]{src/exceptions/exceptions.cpp}

Создан класс \code{Exception}, который хранит внутри себя информацию о номере сигнала и метке (понадобится при изучении вложенных исключений). Кроме того, реализована функция \code{throwException} для бросания исключения при помощи оператора \code{throw}.

\subsection{Генерация исключений}

С точки зрения программы все равно, какой номер сигнала будет передан в конструктор класса \code{Exception}, поэтому будем исследовать только сигнал \code{SIGILL}.

Сгенерируем два исключения, при этом в первый раз обернем вызов \code{throwException} в конструкцию \code{try-catch}.

\listingwithoutput{exception_try_catch}

Видно, что в первом случае исключение было перехвачено блоком \code{catch} и выведена информация об исключении. Второе исключение не было перехвачено, из-за чего в программе была вызвана функция \code{abort}, которая послала программе сигнал \code{SIGABRT}, после чего программа была завершена с кодом 134 (соответствует получению сигнала \code{SIGABRT}).

Проверим, что при необработанном исключении процесс получает сигнал \code{SIGABRT}. Для этого добавим обработчик для этого сигнала.

\listingwithoutput{exception_signal}

Из вывода программы видно, что процесс получил сигнал \code{SIGABRT} из-за необработанного исключения языка \code{C++}.

Исследуем программу \code{exception_signal} при помощи утилиты \code{strace}.

\logs{exception_signal/strace}

Из вывода видно, что сначала был установлен обработчик для сигнала \code{SIGABRT} (с. 6). При необработанном исключении была дважды вызвана функция \code{rt_sigprocmask} для изменения маски сигналов процесса. Из маски блокируемых сигналов был удален сигнал \code{SIGABRT} (с. 11) и добавлен сигнал реального времени (с. 12). Затем при помощи функции \code{tgkill} программе был отправлен сигнал \code{SIGABRT} (с. 13-15). Установленный обработчик вывел информацию о сигнале (с. 18) и восстановил обработчик по умолчанию (с. 20). Затем программа получила сигнал \code{SIGABRT} вновь (с. 24-26) и в этот раз уже была завершена (с. 29).

Аналогичный вывод можно получить при использовании утилиты \code{ltrace} с ключом \code{-S} (выводить системные вызовы).

\logs{exception_signal/ltrace}

%TODO показать раскрутку стека

\subsection{Вложенные исключения}

\subsection{Использование \code{goto} для выхода из \code{try}}

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item 1
	\item 2
\end{itemize}

\newpage

\section*{Список использованных источников}

\begin{enumerate}
	\item Душутина Е.В. -- Системное программное обеспечение. Практические вопросы разработки системных приложений [Текст] -- 2016.
	\item Таненбаум Э. -- Современные операционные системы [Текст] -- 2015.
	\item Linux processes and signals / BogoToBogo [Электронный ресурс]:\\
		{\small\url{https://www.bogotobogo.com/Linux/linux_process_and_signals.php}}
	\item Other Built-in Functions Provided by GCC / GCC Docs [Электронный ресурс]:
		{\small\url{https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html}}
	\item rt\_sigaction(2) - Linux man page [Электронный ресурс]:\\
		{\small\url{https://linux.die.net/man/2/rt_sigaction}}
\end{enumerate}

\end{document}
