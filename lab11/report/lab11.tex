\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

Изучение работы ядра ОС Linux путем встраивания модуля драйвера символьного устройства в ядро операционной системы.

\section{Программа работы}

\input{workprogram}

\section{Используемое окружение}

\begin{itemize}
	\item ОС: Ubuntu
	\item Версия ОС: 19.10
	\item Процессор: Intel® Core™ i7-8550U CPU @ 1.80GHz × 8
	\item ОЗУ: 16 Гб
	\item Компилятор: gcc (Ubuntu 9.2.1-9ubuntu2) 9.2.1 20191008
	\item Отладчик: GNU gdb (Ubuntu 8.3-0ubuntu1) 8.3
\end{itemize}

\section{Модуль ядра}

В данном модуле реализованны 6 функций:

\begin{itemize}
	\item \code{device_init} и \code{device_exit} будут вызваны при вставке и извлечении модуля из ядра;
	\item \code{device_open} и \code{device_release} будут вызваны при открытии и закрытии файла символьного устройства;
	\item \code{device_read} и \code{device_write} будут вызваны для обработки операций чтения и записи из устройства. В целях демонстрации (и упрощения реализации), считывание из файла будет происходит в обратном порядке, нежели чтение. То есть после записи слова <<Hello>>, считано будет слово <<olleH>>.
\end{itemize}

\lstinputlisting[caption=\code{driver.c}]{src/driver/driver.c}

Для модуля важно правильно описать \code{Makefile}. В первой строке указан специальный ключ \code{obj-m}. Цель \code{all} вызывает утилиту \code{make} для сборки кода модуля в рабочий драйвер с расширение \code{.ko}. Цели \code{insmod} и \code{rmmod} используются для встраивания и извлечения модуля из ядра. Цели \code{mknod} и \code{rmnod} используются для создания файла символьного устройства \code{/dev/chardev}, драйвером к которому и является разрабатываемый модуль. Вспомогательные цели \code{print} и \code{log} могут быть использованы для чтения системного журнала в целях отладки.

\lstinputlisting[caption=\code{Makefile}, language={[gnu] make}]{src/driver/Makefile}

Компиляция модуля осуществляется при помощи вызова утилиты \code{make} в директории с исходным кодом модуля.

\section{Обращение к символьному устройству}

Для демонстрации работы драйвера символьного устройства создадим программу, взаимодействующую с устройством через файл \code{/dev/chardev}.

\lstinputlisting[caption=\code{app.c}]{src/app/app.c}

Программа принимает в качестве аргумента строку, которую сначала записывает в символьное устройство, а зачем считывает из него же.
\code{Makefile} для этой программы содержит только одну цель для компиляции программы с помощью \code{gcc}.

\lstinputlisting[caption=\code{Makefile}, language={[gnu] make}]{src/app/Makefile}

\section{Тестирование работы модуля}

Проведем эксперимент с разработанным модулем и программой.

\logs{log}

Рассмотрим выполненные действия построчно:

\begin{enumerate}
	\item[$1-2$] Создание файла символьного устройства
	\item[$4-12$] Сборка модуля ядра
	\item[$14-15$] Встраивание модуля в ядро
	\item[$17-19$] Проверка, что встраивание прошло успешно
	\item[$21-27$] Запуск программы, обращающейся к символьному устройству. Видно, что файл был открыт, в него была записана строка <<Hello, driver!>>, затем было считано 14 байт -- перевернутая записанная строка, после чего файл был закрыт.
	\item[$29-37$] Журналирование работы драйвера
	\item[$39-49$] Извлечение модуля из ядра
	\item[$42-44$] После извлечения модуля, приложение не может произвести запись в символьный файл
	\item[$46-47$] Удаление файла символьного устройства
	\item[$49-51$] После удаления файла символьного устройства, программа не может его открыть
\end{enumerate}

Из вывода журналирования видно, что модуль успешно обработал запросы прикладной программы на открытие, запись, чтение и закрытие символьного устройства. После излечения модуля, запущенное прикладное приложение получило от ОС сигнал Killed (9).

\newpage

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item разработан встраиваемый модуль для ядра ОС Linux; 
	\item разработана программа, взаимодействующая с <<устройством>> через символьный файл в директории \code{/dev};
	\item проведен эксперимент с встраиванием модуля в ядро и взаимодействием программы с файлом символьного устройства.
\end{itemize}

В результате описанных выше этапов был произведен полный цикл работы с модулем ядра ОС Linux.

\section*{Список использованных источников}

\begin{enumerate}
	\item Душутина Е.В. -- Системное программное обеспечение. Практические вопросы разработки системных приложений [Текст] -- 2016.
	\item Таненбаум Э. -- Современные операционные системы [Текст] -- 2015.
\end{enumerate}

\end{document}
