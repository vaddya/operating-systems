\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

Изучение управления процессами и потоками в Windows.

\section{Программа работы}

\input{workprogram}

\section{Используемая операционная система}

\begin{itemize}
	\item ОС: Windows 10 Pro
	\item Версия ОС: 1803 (сборка 17134.345)
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
\end{itemize}

\newpage

\section{Примеры применения функций создания процессов}

\subsection{Создание процесса для запуска приложения}

\paragraph{Задание.} Программа после запуска должна создать новый процесс, с помощью функции \code{CreateProcess}. В новом процессе необходимо запустить любое приложение (например, \code{notepad.exe} или \code{calc.exe}). Для контроля можно вывести идентификаторы созданного процесса и потока, а затем завершить основную программу.

\listingwithoutput{task1}

После запуска программы в новом окне был запущен блокнот \code{notepad.exe}. Информация о созданном процессе была возвращена через указатель на структуру \code{processInfo}.

\subsection{Создание процессов при работе с конфигурационным файлом}

\paragraph{Задание.} Программа, получает имя конфигурационного файла из командной строки, открывает конфигурационный файл, читает строки и создает для запуска каждой команды отдельный процесс.

\listingwithoutput{task2}

\begin{figure}[H]
	\includegraphics[width=\linewidth]{task2.png}
	\caption{Результаты выполнения \code{task2.exe}}
\end{figure}

Из результатов видно, что в новых процессах были запущены калькулятор (\code{calc.exe}) и блокнот (\code{notepad.exe}) с конфигурационным файлом.

\paragraph{Задание.} Доработаем программу. Пусть программа получает имя конфигурационного файла из командной строки, открывает его с помощью \code{fopen()}, читает построчно функцией \code{fgets()}. После прочтения каждой строки, если она не пуста, создается процесс, в командную строку которого пишется прочитанная строка. Если создать процесс не удалось, программа пробует читать конфигурационный файл дальше.

\listingwithoutput{task3}

Сначала программа была запущена без параметров, что привело к выводу ошибки. После этого имя конфигурационного файла было передано как аргумент программы. Аналогично предыдущей программе, в новых процессах были запущены калькулятор (\code{calc.exe}) и блокнот (\code{notepad.exe}) с конфигурационным файлом. Пустая строка во входном файле была корректно обработана.

\newpage

\section{Управление потоками}

\subsection{Создание нескольких потоков}

\paragraph{Задание.} Программа должна создавать два потока, выводящих в бесконечном цикле <<1>> и <<2>> соответственно. После создания дополнительных потоков, поток-родитель завершается: если программа запущена без параметров, то вызывается \code{system("pause")} и \code{return 0}, иначе вызывается \code{ExitThread(0)}.

\listingwithoutput{task4}

Из результатов видно, что в первом случае произошло завершение всего процесса после нажатия клавиши, а во втором -- завершился только главный поток (программа была завершена с помощью нажатия \ctrl{C}).

\subsection{Разработка программы, в которой время жизни процесса и порождаемых в нем потоков задается как параметр}

\paragraph{Задание.} Программа должна получать 2 параметра -- количество создаваемых потоков и время жизни всего приложения. С интервалом в 1 сек каждый рабочий поток выводит о себе информацию и отслеживает состояние переменной, которая устанавливается в заданное значение по истечении времени жизни процесса.

\listingwithoutput{task5}

В программе было создано 3 потока, каждый из которых отслеживал состояние переменной \code{runFlag}. После установки \code{runFlag} в \code{false}, порожденные потоки завершились.

\section{Функции управления приоритетами процессов и потоков}

\subsection{Управление классом приоритета потока}

\paragraph{Задание.} Подготовить программу, в которой у каждого из потоков свой приоритет отличный от других. Все они выполняют одинаковую работу, например, увеличивают каждый свой счетчик. Накопленное значение счетчика, таким образом, отражает относительное суммарное время выполнения потока.

Кроме того, для более точного определения распределения времени между потоками, необходимо производить вычисления используя одно ядро процессора. Для этого напишем функцию \code{useSingleCore()}, внутри которой вызывается функция \code{SetProcessAffinityMask()} с маской ядер, которые процесс может использовать для выполнения.

\listingwithoutput{task6}

Из результатов видно, что значения приоритетов потоков были распределены от -15 (\code{THREAD\_PRIORITY\_IDLE}) до 15 \code{THREAD\_PRIORITY\_TIME\_CRITICAL}. Программа была запущена с аргументом 2, что соответствует установке таймера на 2 секунды. Из значений счетчиков видно, что потоки с приоритетами \code{THREAD\_PRIORITY\_HIGHEST} и \code{THREAD\_PRIORITY\_TIME\_CRITICAL} получили процессорного времени значительно больше других. Кроме того, по неизвестной причине поток с наименьшим приоритетом (\code{THREAD\_PRIORITY\_IDLE}) получил процессорного времени больше, чем оставшиеся 4 потока с более высокими приоритетами.

\subsection{Управление классом приоритета процесса}

\paragraph{Задание.} Усложним задачу и дополним ее возможностью управлять классом приоритетов процесса.

\listingwithoutput{task7}

Из результатов видно, что ни один из потоков не поменял динамический приоритет в процессе выполнения. Больше всего процессорного времени получили поток с приоритетом \code{THREAD\_PRIORITY\_HIGHEST} и поток с приоритетом \code{THREAD\_PRIORITY\_TIME\_CRITICAL}. Потоки с низким приоритетом почти не получили процессорного времени, т.е. наблюдается <<ресурсное голодание>>.

\subsection{Анализ поведения системных функций динамического управления приоритетами процессов и потоков}

\paragraph{Задание.} С помощью программы определить, назначается ли динамическое изменение приоритетов по умолчанию, на все ли потоки воздействует функция \code{SetProcessPriorityBoost}, возможно ли разрешение отдельному потоку в процессе динамически изменять приоритет, если для процесса это запрещено.

\listingwithoutput{task8}

Из результатов видно, что по умолчанию для процессов и потоков разрешено динамическое изменение приоритетов. Затем для второго потока было запрещено изменение динамического приоритета с помощью вызова функции \code{SetThreadPriorityBoost}. Если запретить динамическое изменение приоритетов для процесса (\code{SetProcessPriorityBoost}), то изменение также будет запрещено и для всех потоков. Тем не менее, возможно разрешить отдельному потоку в процессе динамически изменять приоритет, несмотря на то, что для процесса это запрещено.

\newpage

\section{Самостоятельные задания}

\subsection{Исследование работы программ в зависимости от приоритета базового потока}

\paragraph{Задание.} Исследуйте результаты работы программы 3.1 и 3.2 в зависимости от того, какой приоритет назначается базовому потоку: \code{IDLE}, \code{BELOW\_NORMAL}, \code{NORMAL}, \code{ABODE\_NORMAL}, \code{HIGH}, \code{REALTIME}.

\subsection{Заполнение таблицы }

\subsection{Мониторинг и фиксация динамического изменения приоритетов}

\paragraph{Задание.} С помощью утилит CPU Stress, позволяющих нагружать систему, и утилиты мониторинга \code{ProcessExplorer} (или иных утилит) зафиксируйте динамическое изменение приоритетов, приведите результаты в отчете.

\subsection{Наследование дескрипторов}

\paragraph{Задание.} Создайте программу, демонстрирующую возможность наследования:
\begin{enumerate}
	\item дескриптора порождающего процесса,
	\item дескрипторов открытых файлов,
\end{enumerate}
для выполнения этого задания следует учесть, что по умолчанию наследование в Windows откючено и для возможности наследования, необходимо:
\begin{itemize}
	\item разрешить процессу-потомку наследовать дескрипторы,
	\item сделать дескрипторы наследуемыми.
\end{itemize}

\lstinputlisting[caption=\code{parent.cpp}]{src/parent_son/parent/parent.cpp}
\lstinputlisting[caption=\code{son.cpp}]{src/parent_son/son/son.cpp}

\lstinputlisting[language=none]{logs/task1/task1.txt}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item 1
	\item 2
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item Работа с сигналами в Linux. [Электронный ресурс]:\\
		{\small\url{http://manpages.ubuntu.com/manpages/precise/ru/man7/signal.7.html}} 
\end{enumerate}

\end{document}
