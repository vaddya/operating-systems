\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

Изучение управления процессами и потоками в Windows.

\section{Программа работы}

\input{workprogram}

\section{Используемая операционная система}

\begin{itemize}
	\item ОС: Windows 10 Pro
	\item Версия ОС: 1803 (сборка 17134.345)
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
\end{itemize}

\newpage

\section{Создание процессов}

\subsection{Создание процесса для запуска приложения}

\paragraph{Задание.} Программа после запуска должна создать новый процесс, с помощью функции \code{CreateProcess}. В новом процессе необходимо запустить любое приложение (например, \code{notepad.exe} или \code{calc.exe}). Для контроля можно вывести идентификаторы созданного процесса и потока, а затем завершить основную программу.

\listingwithoutput{task1}

После запуска программы в новом окне был запущен блокнот \code{notepad.exe}. Информация о созданном процессе была возвращена через указатель на структуру \code{processInfo}.

\subsection{Создание процессов при работе с конфигурационным файлом}

\paragraph{Задание.} Программа, получает имя конфигурационного файла из командной строки, открывает конфигурационный файл, читает строки и создает для запуска каждой команды отдельный процесс.

\listingwithoutput{task2}

\begin{figure}[H]
	\includegraphics[width=\linewidth]{task2.png}
	\caption{Результаты выполнения \code{task2.exe}}
\end{figure}

Из результатов видно, что в новых процессах были запущены калькулятор (\code{calc.exe}) и блокнот (\code{notepad.exe}) с конфигурационным файлом.

\paragraph{Задание.} Доработаем программу. Пусть программа получает имя конфигурационного файла из командной строки, открывает его с помощью \code{fopen()}, читает построчно функцией \code{fgets()}. После прочтения каждой строки, если она не пуста, создается процесс, в командную строку которого пишется прочитанная строка. Если создать процесс не удалось, программа пробует читать конфигурационный файл дальше.

\listingwithoutput{task3}

Сначала программа была запущена без параметров, что привело к выводу ошибки. После этого имя конфигурационного файла было передано как аргумент программы. Аналогично предыдущей программе, в новых процессах были запущены калькулятор (\code{calc.exe}) и блокнот (\code{notepad.exe}) с конфигурационным файлом. Пустая строка во входном файле была корректно обработана.

\newpage

\section{Создание и управление потоками}

\subsection{Создание нескольких потоков}

\paragraph{Задание.} Программа должна создавать два потока, выводящих в бесконечном цикле <<1>> и <<2>> соответственно. После создания дополнительных потоков, поток-родитель завершается: если программа запущена без параметров, то вызывается \code{system("pause")} и \code{return 0}, иначе вызывается \code{ExitThread(0)}.

\listingwithoutput{task4}

Из результатов видно, что в первом случае произошло завершение всего процесса после нажатия клавиши, а во втором -- завершился только главный поток (программа была завершена с помощью нажатия \ctrl{C}).

\subsection{Разработка программы, в которой время жизни процесса и порождаемых в нем потоков задается как параметр}

\paragraph{Задание.} Программа должна получать 2 параметра -- количество создаваемых потоков и время жизни всего приложения. С интервалом в 1 сек каждый рабочий поток выводит о себе информацию и отслеживает состояние переменной, которая устанавливается в заданное значение по истечении времени жизни процесса.

\listingwithoutput{task5}

В программе было создано 3 потока, каждый из которых отслеживал состояние переменной \code{runFlag}. После установки \code{runFlag} в \code{false}, порожденные потоки завершились.

\section{Управления приоритетами процессов и потоков}

\subsection{Управление классом приоритета потока}

\paragraph{Задание.} Подготовить программу, в которой у каждого из потоков свой приоритет отличный от других. Все они выполняют одинаковую работу, например, увеличивают каждый свой счетчик. Накопленное значение счетчика, таким образом, отражает относительное суммарное время выполнения потока.

Кроме того, для более точного определения распределения времени между потоками, необходимо производить вычисления используя одно ядро процессора. Для этого напишем функцию \code{useSingleCore()}, внутри которой вызывается функция \code{SetProcessAffinityMask()} с маской ядер, которые процесс может использовать для выполнения.

\listingwithoutput{task6}

Из результатов видно, что значения приоритетов потоков были распределены от -15 (\code{THREAD\_PRIORITY\_IDLE}) до 15 \code{THREAD\_PRIORITY\_TIME\_CRITICAL}. Программа была запущена с аргументом 2, что соответствует установке таймера на 2 секунды. Из значений счетчиков видно, что потоки с приоритетами \code{THREAD\_PRIORITY\_HIGHEST} и \code{THREAD\_PRIORITY\_TIME\_CRITICAL} получили процессорного времени значительно больше других. Кроме того, по неизвестной причине поток с наименьшим приоритетом (\code{THREAD\_PRIORITY\_IDLE}) получил процессорного времени больше, чем оставшиеся 4 потока с более высокими приоритетами.

\subsection{Управление классом приоритета процесса}

\paragraph{Задание.} Усложним задачу и дополним ее возможностью управлять классом приоритетов процесса.

\listingwithoutput{task7}

Из результатов видно, что ни один из потоков не поменял динамический приоритет в процессе выполнения. Больше всего процессорного времени получили поток с приоритетом \code{THREAD\_PRIORITY\_HIGHEST} и поток с приоритетом \code{THREAD\_PRIORITY\_TIME\_CRITICAL}. Потоки с низким приоритетом почти не получили процессорного времени, т.е. наблюдается <<ресурсное голодание>>.

\subsection{Анализ поведения системных функций динамического управления приоритетами процессов и потоков}

\paragraph{Задание.} С помощью программы определить, назначается ли динамическое изменение приоритетов по умолчанию, на все ли потоки воздействует функция \code{SetProcessPriorityBoost}, возможно ли разрешение отдельному потоку в процессе динамически изменять приоритет, если для процесса это запрещено.

\listingwithoutput{task8}

Проанализируем вывод программы:

\begin{itemize}
	\item По умолчанию для процесса и потоков разрешено динамическое изменение приоритета (строки \code{4} -- \code{7});
	\item С помощью вызова функции \code{SetThreadPriorityBoost} можно запретить потоку динамическое изменение, при этом оно запрещается только для этого потока (строки \code{10} -- \code{12});
	\item Если запретить динамическое изменение приоритетов для конкретного процесса (\code{SetProcessPriorityBoost}), то изменение также будет запрещено и для всех его потоков (строки \code{15} -- \code{17});
	\item С помощью вызова функции \code{SetThreadPriorityBoost} возможно разрешить отдельному потоку в процессе динамически изменять приоритет, несмотря на то, что для процесса это запрещено (строки \code{20} -- \code{22}).
\end{itemize}

\newpage

\section{Задания для самостоятельного выполнения}

\subsection{Исследование работы программ в зависимости от приоритета базового потока}

\paragraph{Задание.} Исследуйте результаты работы программы \code{task7} в зависимости от того, какой приоритет назначается базовому потоку: \code{IDLE}, \code{BELOW\_NORMAL}, \code{NORMAL}, \code{ABODE\_NORMAL}, \code{HIGH}, \code{REALTIME}.

Выполним \code{task7} со всеми возможными приоритетами процесса.
\lstinputlisting[language=none]{logs/task7/all.txt}

Видно, что установить процессу приоритет \code{REALTIME\_PRIORITY\_CLASS} не удалось, а процессу был назначен приоритет \code{HIGHEST}. Приведем сводную таблицу значений счетчиков в зависимости от приоритета процесса и потока:

\begin{table}[H]
	\centering
	\def\tabcolsep{5pt}
	\caption{Зависимость значений счетчиков от приоритета процесса и потока}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		Thread/Process & \code{IDLE} & \code{BELOW} & \code{NORMAL} & \code{ABOVE} & \code{HIGH} & \code{REALTIME} \\ \hline
		\code{IDLE} & 3 & 3 & 3 & 2 & 2 & -- \\ \hline
		\code{LOWEST} & 3 & 3 & 3 & 2 & 2 & -- \\ \hline
		\code{BELOW} & 3 & 3 & 3 & 2 & 2 & -- \\ \hline
		\code{NORMAL} & 3 & 3 & 4 & 2 & 2 & -- \\ \hline
		\code{ABOVE} & 1230279 & 1310870 & 4 & 1390225 & 1467519 & -- \\ \hline
		\code{HIGHEST} & 2602627 & 2622270 & 3892063 & 2619412 & 2631990 & -- \\ \hline		\code{TIME\_CRIT} & 1372349 & 1311213 & 3892553 & 1229249 & 1164385 & -- \\ \hline
	\end{tabular}
\end{table}

\subsection{Таблица относительных приоритетов}

\paragraph{Задание.} Модифицируйте программу \code{task7} для заполнения таблицы приоритетов текущими данными вашего эксперимента. Сделайте выводы.

Для этого перед выводом итоговых значений счетчиков нормализуем их таким образом, чтобы значение максимального счетчика было равно 15. Выполним программу \code{task9} с установкой различных приоритетов процессу. 
\lstinputlisting[language=none]{logs/task9/task9.txt}

Видно, что как и в предыдущем пункте установить процессу приоритет \code{REALTIME\_PRIORITY\_CLASS} не удалось. Приведем сводную таблицу относительных значений приоритетов потоков в зависимости от приоритета процесса.

\begin{table}[H]
	\centering
	\def\tabcolsep{10pt}
	\caption{Относительные значения приоритетов потоков в зависимости от приоритета процесса}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		Thread/Process & \code{IDLE} & \code{BELOW} & \code{NORMAL} & \code{ABOVE} & \code{HIGH} & \code{REALTIME} \\ \hline
		\code{IDLE} & 1 & 1 & 1 & 1 & 1 & -- \\ \hline
		\code{LOWEST} & 1 & 1 & 1 & 1 & 1 & -- \\ \hline
		\code{BELOW} & 1 & 1 & 1 & 1 & 1 & -- \\ \hline
		\code{NORMAL} & 1 & 1 & 1 & 1 & 1 & -- \\ \hline
		\code{ABOVE} & 8 & 9 & 1 & 7 & 9 & -- \\ \hline
		\code{HIGHEST} & 15 & 15 & 15 & 15 & 15 & -- \\ \hline
		\code{TIME\_CRIT} & 8 & 7 & 15 & 9 & 7 & -- \\ \hline
	\end{tabular}
\end{table}

Из результатов видно, что таблица довольно сильно отличается от теоретической, а поток с приоритетом \code{HIGHEST} получал процессорного времени больше других независимо от приоритета процесса.

\subsection{Мониторинг и фиксация динамического изменения приоритетов}

\paragraph{Задание.} С помощью утилит CPU Stress, позволяющих нагружать систему, и утилиты мониторинга \code{Process Explorer} (или иных утилит) зафиксируйте динамическое изменение приоритетов, приведите результаты в отчете.

Вместо использования утилит CPU Stress, запустим программу \code{task7} с установкой приоритета процесса в \code{HIGHEST}. С помощью утилиты \code{Process Explorer} откроем окно \code{Properties} процесса с вкладкой \code{Threads}.  

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{dynamic.png}
	\caption{Динамическое изменение приоритета}
\end{figure}

Видно, что приоритет одного из запущенных потоков был повышен на два пункта -- с 13 до 15.

\subsection{Наследование дескрипторов}

\paragraph{Задание.} Создайте программу, демонстрирующую возможность наследования:

\begin{enumerate}
	\item дескриптора порождающего процесса,
	\item дескрипторов открытых файлов,
\end{enumerate}
для выполнения этого задания следует учесть, что по умолчанию наследование в Windows отключено и для возможности наследования, необходимо:

\begin{itemize}
	\item разрешить процессу-потомку наследовать дескрипторы,
	\item сделать дескрипторы наследуемыми.
\end{itemize}

Для того, чтобы сделать дескриптор файла наследуемым, внутри программы \code{parent.exe} функции \code{CreateFile()} передается структура \code{SECURITY\_ATTRIBUTES} с установленным флагом \code{bInheritHandle}. Для того, чтобы разрешить потомку наследовать дескрипторы пятым параметром функции \code{CreateProcess()} передается значение \code{TRUE}. Сам дескриптор при этом передается через аргументы командной строки \code{char *argv[]} программы \code{son.exe}.

\lstinputlisting[caption=\code{parent.cpp}]{src/parent_son/parent/parent.cpp}
\lstinputlisting[caption=\code{son.cpp}]{src/parent_son/son/son.cpp}

Запустим программу \code{parent.exe}:
\lstinputlisting[language=none]{logs/parent_son/parent_son.txt}

Видно, что родительский процесс создал дескриптор файла, после чего вызывал функцию \code{CreateProcess}. После этого начал выполнятся порожденный процесс, в котором еще раз вывелся полученный дескриптор. После выполнения содержимое файла \code{file.txt} оказалось следующим:
\lstinputlisting[language=none]{logs/parent_son/file.txt}

Таким образом, с помощью вызова \code{CreateFile()} и \code{CreateProcess()} со специальными флагами возможно наследование файловых дескрипторов.

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item рассмотрены функции создания процессов и управления потоками;
	\item изучены приоритеты процессов и потоков, а также функции для их изменения;
	\item рассмотрено наследование дескрипторов.
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Душутина Е.В. - Системное программное обеспечение. Практические вопросы разработки системных приложений [Текст] -- 2016.
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item Handle Inheritance / Microsoft Docs [Электронный ресурс]:\\
		{\small\url{https://docs.microsoft.com/en-us/windows/desktop/sysinfo/handle-inheritance}} 
\end{enumerate}

\section*{Дополнения к отчету}

\subsection*{Компиляция и сборка проекта}

Компиляция проекта в данной работе производилась с помощью утилиты CMake и набора утилит MinGW. CMake -- кроcсплатформенная утилита для автоматической сборки программы из исходного кода.  Написав однажды небольшой и понятный всем скрипт, можно обеспечить одинаковую сборку проекта на любых платформах, где доступен CMake (Windows, Linux, MacOS и др.). Скрипт, написанный на языке CMake, транслируется в нативные файлы сборки, например \code{Makefile}. MinGW -- набор портированных на Windows утилит GCC, среди которых компиляторы \code{gcc}, \code{g++} и \code{make}. 

Для каждой программы в отчете был создан свой \code{CMakeLists.txt} файл, который содержит описание проекта, например:

\lstinputlisting[language=none, caption=\code{task2/CMakeLists.txt}]{src/task2/CMakeLists.txt}

Разберем построчно \code{CMakeLists.txt}:

\begin{itemize}
	\item Команда \code{cmake\_minimum\_required} проверяет запущенную версию CMake: если она меньше указанного минимума (в данном случае 3.10), то CMake завершает свою работу фатальной ошибкой;
	\item Команда \code{project} задает характеристики проекта (в данном случае только имя);
	\item Команда \code{set} позволяет задавать переменные, в том числе параметры компиляторы (в данном случае устанавливается стандарт языка \code{C++11});
	\item Команда \code{add\_executable} добавляет к проекту исполняемый файл с заданным именем (\code{task2}), который будет скомпилирован из списка исходников (\code{task2.cpp});
	\item Команда \code{file} копирует файл \code{temp.txt} в папку сборки проекта.
\end{itemize}

Проделаем действия в PowerShell, необходимые для того, чтобы скомпилировать исходный файл имея \code{CMakeLists.txt} файл:
\lstinputlisting[language=none, caption=\code{task1/CMakeLists.txt}]{logs/cmake/cmake.txt}

Сначала запускается утилита \code{cmake} с флагом \code{-G "MinGW Makefiles"} (задает генератор, т.е. форму генерируемого проекта). Она генерирует Makefile, который можно запустить с помощью утилиты \code{mingw32-make.exe} (аналог утилиты \code{make} из Linux). Утилита \code{mingw-make.exe} создает исполняемый файл \code{task2.exe}, который после этого запускается.

Альтернативным вариантом компиляции является запуск компилятора MinGW:
\lstinputlisting[language=none, caption=\code{task1/CMakeLists.txt}]{logs/cmake/g++.txt}

Аргументы утилиты \code{mingw32-g++.exe}, входящей в набор MinGW, аналогичны компилятору \code{g++} на Linux.

\newpage

\subsection*{Приоритеты потоков в планировщике Windows 10}

Согласно документации на сайте Microsoft \footnote{\url{https://docs.microsoft.com/en-us/windows/desktop/procthread/scheduling-priorities}}, потоки в Windows 10 планируются на основе их приоритета планирования (от 0 -- низший приоритет, до 31 -- наивысший). ОС выделяет временные интервалы по кругу (Round Robin) всем потокам с наивысшим приоритетом и переходит к менее приоритетным потокам при отсутствии более приоритетных потоков, готовых к выполнению. Приоритет потока определяется:

\begin{itemize}
	\item классом приоритета процесса (6 классов);
	\item уровнем приоритета потока внутри процесса (7 уровней).
\end{itemize}

Эти два значения формируют базовый приоритет потока:

\begin{table}[H]
	\centering
	\def\tabcolsep{10pt}
	\caption{Приоритеты потоков в Windows 10}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		Thread/Process & \code{IDLE} & \code{BELOW} & \code{NORMAL} & \code{ABOVE} & \code{HIGH} & \code{REALTIME} \\ \hline
		\code{IDLE} & 1 & 1 & 1 & 1 & 1 & 16 \\ \hline
		\code{LOWEST} & 2 & 4 & 6 & 8 & 11 & 22 \\ \hline
		\code{BELOW} & 3 & 5 & 7 & 9 & 12 & 23 \\ \hline
		\code{NORMAL} & 4 & 6 & 8 & 10 & 13 & 24 \\ \hline
		\code{ABOVE} & 5 & 7 & 9 & 11 & 14 & 25 \\ \hline
		\code{HIGHEST} & 6 & 8 & 10 & 12 & 15 & 26 \\ \hline
		\code{TIME\_CRIT} & 15 & 15 & 15 & 15 & 15 & 31 \\ \hline
	\end{tabular}
\end{table}

От приведенной в пособии таблицы приоритетов данная таблица отличается только двумя значениям:

\begin{itemize}
	\item поток \code{ABOVE} в процессе \code{HIGH} имеет приоритет 14 (было 15);
	\item поток \code{ABOVE} в процессе \code{REALTIME} имеет приоритет 25 (было 26).
\end{itemize}

Таким образом параметры планировщика в Windows 10 претерпели небольшие изменения.

\newpage

\subsection*{Список открытых процессом файловых дескрипторов}

Для того, чтобы в задании с наследованием файлового дескриптора порожденным процессом (\code{parent\_son}), получить список открытых файловых дескрипторов воспользуемся утилитой Process Explorer. Добавим в обоих программа вызов \code{system("pause")} и зафиксируем список открытых ими файловых дескрипторов.
\begin{figure}[H]
	\centering
	\begin{subfigure}{\linewidth}
		\includegraphics[width=\linewidth]{parent_handles.png}
		\vspace{0.5em}
	\end{subfigure}
	\begin{subfigure}{\linewidth}
		\includegraphics[width=\linewidth]{son_handles.png}
	\end{subfigure}
	\caption{Открытые файловые дескрипторы}
\end{figure}
Видно, что в списке открытых файловых дескрипторов как родительского, так и порожденного процесса содержится дескриптор файл \code{file.txt}, при этом в порожденном процессе он не создавался с помощью \code{CreateFile()}, а был был унаследован от родительского процесса.

\end{document}
