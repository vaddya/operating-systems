<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="UnixShell.files/filelist.xml">
<title>Shell</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Igor</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Igor</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>0</o:TotalTime>
  <o:Created>2006-12-31T23:52:00Z</o:Created>
  <o:LastSaved>2006-12-31T23:52:00Z</o:LastSaved>
  <o:Pages>7</o:Pages>
  <o:Words>2390</o:Words>
  <o:Characters>13625</o:Characters>
  <o:Company>Home</o:Company>
  <o:Lines>113</o:Lines>
  <o:Paragraphs>31</o:Paragraphs>
  <o:CharactersWithSpaces>15984</o:CharactersWithSpaces>
  <o:Version>10.2625</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->
</head>

<body lang=RU style='tab-interval:35.4pt'>

<div class=Section1>

<p class=MsoNormal align=center style='text-align:center'>Лабораторная работа №
1 </p>

<p align=center style='text-align:center'>по дисциплине &quot;Операционные
системы и среды&quot; </p>

<p align=center style='text-align:center'><b>ИНТЕРПРЕТАТОРЫ КОМАНДНОЙ СТРОКИ ОС
LINUX</b></p>

<p>Цели работы: </p>

<p>1) Изучение основных команд пользовательского интерфейса </p>

<p>2) Изучение цикла подготовки и исполнения программ </p>

<p>3) Изучение команд и утилит обработки текстов </p>

<p align=center style='text-align:center'><b>Программа работы</b></p>

<p><b><i>I. Подготовка к работе.</i></b> </p>

<p>1.&nbsp; Получить у преподавателя входное имя (account) и пароль (password)
для регистрации пользователя в ОС Linux. </p>

<p>После успешной загрузки операционной системы появляется окно регистрации пользователя.
В нём необходимо заполнить строки&nbsp; регистрационного имени (login), и
пароля (passwd). Символы пароля при вводе на экране не отображаются или
отображаются звёздочками. </p>

<p>После успешного ввода регистрационного имени и пароля производится завершение
загрузки ОС (конфигурация графической оболочки). Дальнейшая работа с ОС
осуществляется путём вызова необходимых программ из Панели задач либо из
Главного меню. </p>

<p>2.&nbsp; Для выполнения лабораторных работ рекомендуется использовать режим
терминала. В этом режиме обработку командных строк осуществляет интерпретатор
командной строки - shell. </p>

<p>3. Создать файл отчета. <br>
Создать файл можно переназначив вывод с экрана в файл. </p>

<p>$ &gt;myfile.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (образуется пустой файл
с именем myfile.txt). </p>

<p>В процессе работы Вам следует копировать в этот файл те фрагменты
(сообщения, результаты выполнения команд, т.д.), которые Вы планируете
представить в отчете. </p>

<p>Просмотр и редактирование файла отчета (равно как и любого другого
текстового файла) можно производить в текстовых редакторах (как встроенных в
графическую оболочку, так и вызываемых непосредственно из shell). </p>

<p><b><i>II. Основы работы c командным интерфейсом.</i></b> </p>

<p>Единицей действия является команда. Значением команды служит код завершения.
</p>

<p>Синтаксис команд в большинстве случаев имеет вид: </p>

<p>имя_команды&nbsp; [флаги]&nbsp; [аргументы]&nbsp; . </p>

<p>Команда передается системе только после нажатия &lt;Enter&gt;, т.о. при
неправильном наборе можно затереть один&nbsp; или&nbsp; несколько&nbsp;
символов с помощью клавиши DEL , или всю строку -- &lt;^U&gt;. </p>

<p>1. Введите следующие информационные команды для получения полезных сведений
об ОС и текущем сеансе: </p>

<p>date -- вывод текущей даты; <br>
who&nbsp; -- кто находится в системе; <br>
who am i&nbsp; ; <br>
tty&nbsp; -- полное имя файла-терминала; <br>
logname -- входное имя; <br>
uname&nbsp; --&nbsp; имя&nbsp; UNIX-системы&nbsp; (&quot;имя компьютера&quot;) </p>

<p>Прокомментируйте ответы системы. </p>

<p>2. Введите команду: </p>

<p>sleep 5&nbsp; ( &quot;спать&quot; 5 секунд ). </p>

<p>Через 5 секунд появиться очередное приглашение ' $'. Введите затем: </p>

<p>sleep 10000 </p>

<p>Через какое время вновь должно появиться приглашение ? Пошлите команде sleep
сигнал прерывания (SIGINT --&nbsp; INTERRUPT) , введя символ &lt;^C&gt;. Как
отреагировала система? </p>

<p>3. Справочное руководство </p>

<p>Используйте команду ' man '&nbsp; для&nbsp; получения справочной
информации&nbsp; о различных командах системы ( 'man date' , 'man who' , ' man
tty ' и т.д.&nbsp; ). </p>

<p>Выявите общие правила построения справочников в ОС Linux (разделы и т.п.). </p>

<p>4. Работа с файлами </p>

<p>Для навигации в файловой системе ОС Linux служат файловые менеджеры.
Файловым менеджером, аналогичным Norton Commander (для MS-DOS, Win9x), является
программа Midnight Commander. Её вызов производится командой mc. <br>
Для&nbsp; создания&nbsp; файлов&nbsp; используйте текстовые редакторы,
встроенные в графическую оболочку системы. </p>

<p>a) Для получение информации о файлах из командной строки служит команда ls <br>
Введя команду ls, получим (здесь и далее приведены примерные реакции системы): </p>

<p>$ ls <br>
junk <br>
temp <br>
$ </p>

<p>- команда&nbsp; перечисляет имена существующих в вашем каталоге файлов. <br>
Используя команду&nbsp; ls&nbsp; с ключом&nbsp; -l, получим: </p>

<p>$ ls -l <br>
total 2 <br>
rw-r--r--&nbsp;&nbsp; 1 buc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
people&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 Aug 30 17:28 junk <br>
rw-r--r--&nbsp;&nbsp; 1 buc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
people&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 Aug 30 17:28 temp <br>
$ <br>
Прокомментируйте результат.&nbsp; Что&nbsp; будет,&nbsp; если&nbsp;
ввести&nbsp; 'ls junk' ? 'ls junk temp' ? </p>

<p>b) Вывод содержимого файлов. Выведите содержимое&nbsp; имеющихся&nbsp; у вас
файлов с помощью команды cat : </p>

<p>$ cat junk <br>
$ cat temp <br>
$ cat junk temp </p>

<p>Что происходит, если cat получает несколько аргументов ? </p>

<p>c) Операции с файлами <br>
Переименование файла осуществляется пересылкой его от одного имени к другому
(mv -- move): </p>

<p>$ mv junk aaa <br>
$ ls <br>
aaa <br>
temp <br>
$ cat junk <br>
cat: cannot open
junk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(junk`а уже нет) <br>
$ </p>

<p>Копирование файлов осуществляется с помощью команды cp: </p>

<p>$ cp aaa bbb <br>
$ ls <br>
aaa <br>
bbb <br>
temp <br>
$ </p>

<p>Удаляет файлы команда rm : </p>

<p>$ rm temp junk <br>
rm: junk non-existent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (файла junk на
существует) <br>
$ </p>

<p>$ rm aaa bbb <br>
$ ls <br>
$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(никаких файлов нет) </p>

<p>Поинтересуйтесь в справочном руководстве работой&nbsp; mv&nbsp; , cp и rm . </p>

<p>5. Работа с каталогами. </p>

<p>Определите полное имя вашего текущего&nbsp; каталога с помощью&nbsp;
команды&nbsp; pwd . Создайте произвольный файл&nbsp; prog.c. Как по-вашему
должно выглядеть полное имя файла prog.c ? </p>

<p>Введите ' ls &lt;имя_вашего_каталога&gt; '&nbsp; .&nbsp; Как&nbsp; выводимые
данные соотносятся с выводом &quot;простой&quot; команды 'ls'?&nbsp;
Введите&nbsp; ,&nbsp; 'ls / ' , 'ls -l /' . Что можно сказать о содержимом
каталога /bin ? </p>

<p>Перейдите в вышележащий каталог с помощью команды cd : </p>

<p>cd .. </p>

<p>Определите его полное имя и содержимое. <br>
Поднимитесь еще &quot;выше&quot;. Определите полное имя. <br>
Поднимитесь еще &quot;выше&quot;. Куда вы попали? Куда будете попадать, если
продолжать это до бесконечности? </p>

<p>С помощью команды ls с ключами 'l' и 'd' ('ls -ld') определите владельцев
каталогов / , /bin , и вашего домашнего каталога. Можете ли&nbsp; вы изменить
содержимое каталогов / или /bin? </p>

<p>Вернитесь в свой домашний каталог с помощью команды cd без аргументов.
Проверьте результат. </p>

<p>Создайте в своем каталоге подкаталог командой mkdir : </p>

<p>mkdir&nbsp; &lt;имя_каталога&gt; </p>

<p>Перейдите в него ( cd &lt;имя_каталога&gt; ). Нужно ли указывать&nbsp;
полное маршрутное имя для перехода? В каком случае это было бы необходимо ? <br>
Скопируйте в новый каталог какой-либо файл из вышележащего (исходного)
каталога: </p>

<p>cp ../prog.c&nbsp; . </p>

<p>( '.' -- синоним текущего каталога, '..' -- вышележащего. В случае, если 2-й
аргумент команды cp -- каталог, файл копируется в него под тем же именем. ) <br>
Вернитесь в вышележащий каталог. (Сколькими способами в данном случае это можно
сделать? ). Выполните команду ls. <br>
Попробуйте&nbsp; удалить&nbsp; свой&nbsp; подкаталог с помощью команды
rmdir&nbsp; .&nbsp; Каков&nbsp; результат? Удалите файлы из этого каталога ( rm
&lt;имя&gt;/prog.c ) и повторите попытку его&nbsp; удаления.&nbsp; Что
получилось? (' ls '). </p>

<p>6. Процессы ОС Linux </p>

<p>Введите команду ps -- информация о процессах, запущенных&nbsp; с вашего
терминала. Более полную информацию о процессах в системе предоставляет команда ps
с ключом -A. Прокомментируйте полученную информацию, для чего обратитесь к
справочному руководству. </p>

<p><b><i>III. Изучение цикла подготовки и исполнения программ в ОС Linux.</i></b>
</p>

<p>Язык С тесно связан с ОС UNIX,&nbsp; т.к. первоначально был разработан
именно для реализации ядра ОС. В первую очередь, он удобен для задач,&nbsp;
использующих системные вызовы, например, для управления памятью&nbsp; и
физическими устройствами, организации связи между процессами и т.д. Однако, С
успешно применяется и для реализации программ,&nbsp; не требующих такого
непосредственного взаимодействия с ОС.&nbsp; Цикл выполнения программ в UNIX
аналогична большинству других ОС. <br>
Файлы с исходными текстами С-программ должны иметь расширение '.с'. Команда
вызова компилятора имеет следующий вид: </p>

<p>сс &lt;имя_программы&gt; </p>

<p>При успешном исходе компиляции после нее будет выполнено&nbsp;
редактирование связей и сгенерирован выполняемый файл 'a.out'.&nbsp; Для
управления процессом компиляции и редактирования связей команда 'сс' имеет
несколько опций, в том числе: <br>
-с - подавляется фаза редактирования&nbsp; связей. Генерируется объектный файл,
который может быть использован для редактирования связей с помощью команды 'сс'
без опции -с; <br>
- о &lt;вых.файл&gt; - выполняемый файл, полученный после редактирования
связей, будет иметь имя &lt;вых.файл&gt;, а не 'a.out'. <br>
Остальные опции, используемые командой 'сс', описаны в справочном руководстве. <br>
Редактор связей объединяет несколько объектных файлов в один, выполняет
настройку ссылок, включает процедуры инициализации и генерирует таблицу
имен,&nbsp; используемую отладчиком. Разумеется , можно выполнять
редактирование связей и в случае единственного объектного файла. Результат
редактирования по умолчанию помещается в файл 'a.out'. Команда 'ld' вызывает
редактор связей непосредственно. Однако обычно эта команда не используется. Как
правило, применяется команда запуска системы компиляции того или иного языка
(например, 'сс', 'gcc', 'g++'), которая сама вызывает редактор связей. </p>

<p>Информация или управляющие параметры могут&nbsp; передаваться в С-программу
как&nbsp; аргументы командной строки при запуске программы. При этом указанные
в командной строке&nbsp; аргументы&nbsp; передаются функции main() через два ее
параметра,&nbsp; первый из которых содержит количество аргументов, а второй
является массивом указателей на цепочки символов, содержащие передаваемую в
качестве аргументов информацию (выполнение любой С-программы начинается с
функции main()).&nbsp; Обычно параметры функции main() имеют имена argc и argv,
хотя это и не обязательно.&nbsp; Argc - целое число, равное количеству
передаваемых&nbsp; аргументов.&nbsp; Это&nbsp; число всегда больше или равно 1,
поскольку сама команда считывается первым аргументом, и arg[0] является&nbsp;
указателем на цепочку символов,&nbsp; представляющую команду. </p>

<p>С помощью любого текстового редактора создайте файл prog.c, содержащий следующий
исходный текст С-программы: </p>

<p>&nbsp;#include &lt;stdio.h&gt; <br>
main () <br>
{ <br>
printf (&quot;Hello, everybody ! &quot;); <br>
} </p>

<p>Создайте объектный&nbsp; файл.&nbsp; Определите, какое ему присвоено имя.
Соберите исполняемый файл. Проанализируйте результат. Получите
исполняемый&nbsp; файл&nbsp; с именем hello из файла с исходным текстом.
Проверьте работоспособность полученных исполняемых&nbsp; файлов. Переназначьте
вывод программы в файл res. Проверьте результат. </p>

<p>Для изучения&nbsp; передачи&nbsp; информации&nbsp; в&nbsp; С-программы
создайте файл с именем my_open.с, содержащий исходный&nbsp; текст&nbsp;
следующей С-программы. </p>

<p>&nbsp;#include &lt;stdio.h&gt; <br>
main ( argc, argv ) <br>
int argc; <br>
char *argv []; <br>
{ <br>
if (argc &gt; 1) { <br>
&nbsp;&nbsp; if (fopen(argv[1],&quot;r&quot;) == NULL) { <br>
printf(&quot;%s: неудача при попытке открыть файл %s&quot;,argv[0],argv[1]); <br>
&nbsp; else <br>
printf(&quot;%s: файл %s открыт&quot;,argv[0],argv[1]); <br>
} <br>
else <br>
&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;открываемый файл не указан&quot;); <br>
} </p>

<p>Создайте исполняемый файл. Исполните программу, передавая в качестве
аргумента имя реально существующего файла&nbsp; (предварительно создайте&nbsp;
его),&nbsp; имя не существующего файла и не указывая никакого аргумента.
Проанализируйте результаты. </p>

<p>В ОС UNIX есть возможность направлять выходной поток&nbsp; одной программы
на вход другой программы - организация конвейера. Откорректируйте первую
программу, создав файл file_name.c, таким образом, чтобы на печать выводилось
имя файла (существующего или не существующего).&nbsp; Получите исполняемую
программу с именем file_name. Попытайтесь организовать конвейер из двух
созданных исполняемых программ командой: </p>

<p>file_name||my_open </p>

<p>а также другой командой: </p>

<p>file_name|my_open </p>

<p>Проанализировав полученные результаты, уясните различие двух использованных
типов конвейеров. Если не удалось выполнить конвейер команд, исправьте тексты
С-программ требуемым образом. В отчете представьте пояснения выполненным Вами
действиям. </p>

<p><b><i>IV. Изучение команд и утилит обработки текстов.</i></b> </p>

<p>Существует большое&nbsp; число&nbsp; команд&nbsp; UNIX,&nbsp; которые&nbsp;
читают входной поток,&nbsp; выполняют&nbsp; простые операции над ним и
записывают результат в выходной поток.&nbsp; Такие программы называются фильтрами.
Многие команды могут быть фильтрами, поскольку обычно в случае незадания
файла-аргумента читается стандартный ввод.&nbsp; Важной особенностью
фильтров&nbsp; является то,&nbsp; что они никогда не изменяют исходных
файлов,&nbsp; а лишь выводят на стандартный вывод обработанную
информацию.&nbsp; Стандартный&nbsp; вывод&nbsp; также можно переназначить в
файл. </p>

<p>1. G r e p - поиск по шаблону, заданному регулярным выражением </p>

<p>Команда grep имеет следующий синтаксис: </p>

<p>grep [опции] &lt;шаблон&gt; [файл ...] </p>

<p>Команда grep сопоставляет строки исходных файлов с шаблоном, заданным
ограниченным регулярным выражением. Если файлы не указаны, используется
стандартный ввод. Обычно каждая успешно сопоставленная строка копируется на
стандартный вывод; если исходных файлов несколько,&nbsp; перед найденной
строкой&nbsp; выдается&nbsp; имя файла. В&nbsp; качестве шаблонов
воспринимаются ограниченные регулярные выражения - см. справочное руководство
по команде 'grep'. <br>
Для экранирования символов $,*,[],^,!,() и \ от интерпретации shell проще всего
заключать ограниченное регулярное выражение в одинарные кавычки. <br>
Перечень опций команды также рекомендуется изучить, пользуясь справочным
руководством. </p>

<p>Выведите только те строки из вывода ls -l /tmp, которые: <br>
1) соответствуют каталогам; <br>
2) соответствуют выполняемым для всех файлам; <br>
3) принадлежат пользователь root; <br>
4) не принадлежат пользователю root. </p>

<p>2. C u t&nbsp; - выборка отдельных полей из строк файла </p>

<p>Команда cut имеет следующий синтаксис: </p>

<p>&nbsp;cut -cсписок [файл ...] </p>

<p>cut -fсписок [-dсимвол][-s][файл ...] </p>

<p>Команда cut используется для выборки колонок из таблицы или полей из каждой
строки файла. Поля, специфицированные списком, могут быть фиксированной (опция
-с) или переменной длины&nbsp; (опция -f). В случае переменной длины поля
границей поля является символ-разделитель (опция -d). По умолчанию разделителем&nbsp;
является символ табуляции. Значения опций следует уточнить по справочному
руководству. </p>

<p>Определите с использованием команды cut: <br>
1) номера запущенных Вами процессов; <br>
2) идентификаторы пользователей,&nbsp; имеющих&nbsp; x-терминалы на Вашей
рабочей станции; <br>
3) Ваше входное имя в системе. </p>

<p>3. T r&nbsp; -&nbsp; преобразователь символов </p>

<p>Команда tr имеет следующий синтаксис: </p>

<p>&nbsp;tr [опции] цепочка1 цепочка2 </p>

<p>Команда tr копирует стандартный ввод на стандартный вывод с заменой либо
удалением выбранных символов.&nbsp; Символы, найденные в цепочке1,&nbsp;
заменяются&nbsp; на&nbsp; соответствующие&nbsp; символы из цепочки2. Чтобы
помещать в цепочки отрезки&nbsp; алфавита,&nbsp; можно&nbsp; использовать
сокращение: [c1-c2] -- цепочка символов, коды ASCII которых принадлежат отрезку
от кода символа с1 до с2. </p>

<p>Выведите информацию о ваших файлах прописными буквами. </p>

<p>4. S o r t - сортировка и / или слияние файлов </p>

<p>Команда sort имеет следующий синтаксис: </p>

<p>&nbsp;sort [опции] [файл...] </p>

<p>Команда sort сортирует строки,&nbsp; входящие во все исходные файлы, и
выдает результат на стандартный вывод. При упорядочении используется один или
несколько ключей сортировки, выделяемых из каждой вводимой строки. По умолчанию
ключ сортировки один - вся строка, а порядок является&nbsp;
лексикографическим,&nbsp; соответствующим принятой кодировке символов. Опции,
изменяющие стандартный порядок работы, изучите по справочному руководству. </p>

<p>Отсортируйте файлы в вашем каталоге (ls -l): <br>
1) в алфавитном порядке, <br>
2) в порядке увеличения размеров файлов, <br>
3) в порядке уменьшения размеров файлов. </p>

<p>5. U n i q&nbsp; -&nbsp; выдача информации о повторяющихся строках файла </p>

<p>Команда uniq имеет следующий синтаксис: </p>

<p>&nbsp;uniq [опции] [исходный файл [выходной файл]] </p>

<p>Команда uniq&nbsp; читает&nbsp; исходный&nbsp; файл&nbsp; и сравнивает
соседние строки. В обычном режиме вторая и последующие копии повторяющейся
строки исключаются;&nbsp; остаток поступает в выходной файл, который не должен
совпадать с исходным. Для того, чтобы повторяющиеся строки были соседними, файл
надо отсортировать. </p>

<p>Выведите повторяющиеся размеры файлов из каталога /usr/bin. Для этого из
вывода ls -l с помощью cut оставьте только размеры, отсортируйте
полученный&nbsp; поток&nbsp; и&nbsp; из результата выделите только повторения. </p>

<p>6. C m p&nbsp; - сравнение двух файлов </p>

<p>Команда cmp имеет следующий синтаксис: </p>

<p>&nbsp;cmp [опции] файл1 файл2 </p>

<p>Команда cmp производит побайтное сравнение и прекращает работу при первом
несовпадении. </p>

<p>Сравните файлы исходных текстов и объектные файлы созданных С-программ. </p>

<p>7. D i f f&nbsp; -&nbsp; выявление различий между файлами </p>

<p>Команда diff имеет следующий синтаксис: </p>

<p>diff [опции] файл1 файл2 </p>

<p>Команда diff выдает на стандартный вывод только те строки файлов, которые
нужно изменить, чтобы привести файлы в соответствие друг с другом. </p>

<p>Сравните prog.c и my_open.c с помощью diff: </p>

<p>diff -e prog.c my_open.c &gt; eqv </p>

<p>Проанализируйте содержимое eqv. </p>

<p><b><i>V. Оформление отчета.</i></b> </p>

<p>Отредактировать и оформить отчет по лабораторной работе. </p>

<p><b><i>VI. Завершение работы.</i></b> </p>

<p>Для завершения работы необходимо выполнить стандартную процедуру завершения
пользовательского сеанса. <br>
&nbsp; </p>

</div>

</body>

</html>
