\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

Изучить средства межпроцессного взаимодействия в ОС семейства UNIX на примере Linux:

\begin{itemize}
	\item сигналы;
	\item анонимные (неименованные) каналы;
	\item именованные каналы;
	\item очереди сообщений;
	\item семафоры;
	\item разделяемая память;
	\item сокеты.
\end{itemize}

\section{Программа работы}

\input{workprogram}

\newpage

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Сигналы}

\subsection{Ненадежные сигналы}

Создать программу, позволяющую изменить диспозицию сигналов, а именно, установить:

\begin{itemize}
	\item обработчик пользовательских сигналов \code{SIGUSR1} и \code{SIGUSR2};
	\item реакцию по умолчанию на сигнал \code{SIGINT};
	\item игнорирование сигнала \code{SIGCHLD};
\end{itemize}

Повторить эксперимент для других сигналов, для процессов, порождаемых в разных файлах, для потоков одного процесса, для потоков разных процессов.

\lstsrc{sigexam/sigexam}

Запустим программу \code{sigexam} в фоновом режиме и отправим ей несколько сигналов.

\lstlogs{sigexam/sigexam}

Видно, что сначала порожденный процесс отправил родительскому сигнал \code{SIGUSR1} и он его успешно обработал. Затем с консоли было отправлено несколько сигналов, в результате которых родительский процесс успешно обработал сигнал \code{SIGUSR2}, проигнорировал \code{SIGCHLD} и был завершен после получения сигнала \code{SIGINT}.

Попробуем отправить сигнал \code{SIGHUP}:

\lstlogs{sigexam/othersignals}

Видно, что так как процесс не установил обработчик на этот сигнал, он был завершен.

Попробуем отправить сигнал другому процессу. Для этого создадим простую программу \code{sigsender}, которая будет отправлять сигнал процессу, получая и номер сигнала, и номер процесса из параметров командной строки.

\lstsrc{sigexam/sigsender/sigsender}

Запустим \code{sigexam}, после чего запустим \code{sigsender}, передав программе PID процесса \code{sigexam} и номер сигнала \code{SIGHUP}:

\lstlogs{sigexam/sigsender}

Видно, что сигнал был успешно отправлен и программа \code{sigexam} была завершена.

Попробуем отправить сигнал из одного потока другому в рамках одного процесса. Для этого создадим программу \code{sigthread}, использующую библиотеку \code{pthread}. Внутри программы создается два потока, выводящие сообщение раз в 1 или 5 секунд соответственно. Одна из нитей отправляет другой ните, которая установила обработчик на сигнал \code{SIGUSR1}, этот сигнал.

\lstsrc{sigexam/sigthread/sigthread}

Запустим \code{sigthread}:

\lstlogs{sigexam/sigthread}

Видно, что вторая нить успешно обработала сигнал и завершилась при помощи вызова \code{pthread_exit()}. Нить, отправившая сигнал продолжила свое выполнение.

Отправить сигнал из нити одного процесса ните другого при помощи \code{pthread_kill}, как следует из документации, нельзя: \code{pthread_kill} отправляет сигнал ните в том же процессе, что и вызывающая.

\subsection{Надежные сигналы}

Создать программу, позволяющую продемонстрировать возможность отложенной обработки (временного блокирования) сигнала (например, \code{SIGINT}).

Используем программу \code{sigact}. В ней определяется функция \code{mysig}, которая принимает номер сигнала и обработчик и заполняет нужные поля структуры \code{sigaction} и вызывает функцию \code{sigaction} для установки обработчика сигнала.

\lstsrc{sigact/sigact}

Запустим \code{sigact} в фоновом режиме и отправим сигнал \code{SIGUSR1}. После этого процесс засыпает на 60 секунд. В течении этого времени отправим сигнал \code{SIGINT}.

\lstlogs{sigact/sigact}

Видно, что из-за использования надежной обработки сигналов, сигнал \code{SIGINT} не был потерян, а был отложен и обработан спустя 60 секунд.

Изменим обработчик сигнала так, чтобы из него производилась отправка другого сигнала. Для этого модифицируем программу \code{sigact} и назовем \code{sighandler}.

\lstsrc{sigact/sighandler/sighandler}

Запустим \code{sighandler}:

\lstlogs{sigact/sighandler}

При генерации сигнала (в данном случае \code{SIGINT}) из обработчика другого
сигнала обработка сгенерированного сигнала задерживается до конца
выполнения текущего обработчика (как и в предыдущем эксперименте).

\subsection{Сигналы реального времени}

Проведите эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени, (более двух сигналов, для этого увеличьте «вложенность» вызовов обработчиков). Экспериментально подтвердите, что обработка равноприоритетных сигналов реального времени происходит в порядке FIFO. Опытным путем подтвердите наличие приоритетов сигналов реального времени.

Начиная с 32 указаны сигналы реального времени. Они были разработаны в процессе поиска решения проблемы появления сигнала во время обработки другого сигнала и имеют несколько ключевых отличий от базовых.

Сигналы реального времени помещаются в очередь, если сигнал будет порожден несколько раз, он будет несколько раз получен адресатом. Повторения одного и того же сигнала доставляются в порядке очереди FIFO. Если сигналы в очередь не помещаются, неоднократно порожденный сигнал будет получен лишь один раз. Сигналы реального времени с меньшим номером будут обработаны раньше. Если же одновременно посылаются несколько обычных сигналов, то они сливаются в один.

Рассмотрим отличия сигналов с помощью программы \code{sigrt.c}, внутри которой создается две нити, одна из которых отправляет другой обычные сигналы и сигналы реального времени.

\lstsrc{sigrt/sigrt}

Запустим \code{sigrt}:

\lstlogs{sigrt/sigrt}

Из результатов видно, что:

\begin{itemize}
	\item Сигналы реального времени имеют больший приоритет в сравнении с базовыми сигналами;
	\item Сигналы реального времени с большим номером имеют больший приоритет перед сигналами реального времени с меньшими номерами;
	\item Обычные сигналы пришли не в том порядке;
	\item Одинаковые сигналы реального времени не слились в один, в отличии от базовых;
	\item Сигнал \code{SIGKILL} невозможно перехватить.
\end{itemize}

\section{Каналы}

\subsection{Неименованные каналы}

\paragraph{Задание.} Организуем программу \code{pipe.c} так, чтобы процесс-родитель создавал неименованный канал, создавал потомка, закрывал канал на запись и записывал в произвольный текстовый файл считываемую из канала информацию. В функции процесса-потомка будет входить считывание данных из файла и запись их в канал.

\lstsrc{pipe/pipe}

Создадим файл \code{from.txt} и запустим \code{pipe}:

\lstlogs{pipe/pipe}

Видно, что содержимое файла \code{from.txt} успешно переписалось в изначально пустой файл \code{to.txt} с использованием неименованного канала. Так как процесс-родитель только читает из канала, то дескриптор для записи \code{fds[1]} он закрывает, аналогично порожденный процесс в начале работы закрывает дескриптор для чтения из канала \code{fds[0]}.

\subsection{Именованные каналы}

\paragraph{Задание.} Создать клиент-серверное приложение, демонстрирующее дуплексную (двунаправленную) передачу информации двумя однонаправленными именованными каналами между клиентом и сервером.

В файле \code{server.c} создадим 2 именованных канала, используя системный вызов \code{mknod()} (аргументы: имя файла FIFO в файловой системе; флаги владения,
прав доступа -- установим открытые для всех права доступа на чтение и на
запись \code{S_IFIFO | 0666}).

Откроем один канал на запись (\code{chan1}), другой - на чтение (\code{chan2}) и запустим серверную часть программы: запишем имя файла в канал 1 (для записи) функцией \code{write()} и прочитаем данные из канала 2 и выведем на экран.

В файле \code{client.c} запрограммируем функции: открытия каналов для чтения
(\code{chan1}) и записи (\code{chan2}). Из первого канал читается имя файла, а во второй канал пишется его содержимое.

\lstsrc{pipes/server/server}

\lstsrc{pipes/client/client}

Запустим \code{server} и \code{client}:

\lstlogs{pipes/server}

\lstlogs{pipes/client}

Видно, что сначала сервер записал в первый канал имя файла, из которого необходимо прочитать данные: \code{../text.txt}. Затем клиент при запуске прочитал из этого канала имя файла, открыл файл и записал его содержимое во второй канал. После этого сервер считал из второго канала содержимое файла и вывел в консоль. Таким образом была успешно продемонстрирована двунаправленная передача информации с использованием однонаправленных именованных каналов. 

\section{Очереди сообщений}

\paragraph{Задание.} Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очередей сообщений.

Очередь сообщений находится в адресном пространстве ядра и имеет
ограниченный размер. В отличие от каналов, которые обладают теми же
самыми свойствами, очереди сообщений сохраняют границы сообщений.

\lstsrc{queue/server/server}

\lstsrc{queue/client/client}

Запустим \code{server} и двух \code{client}:

\lstlogs{queue/server}

\lstlogs{queue/client1}

\lstlogs{queue/client2}

Сервер получает ключ по имени файла. С помощью ключа и идентификатора он получает очередь сообщений и ждет сообщений с типом 1 от клиентов. При получении сообщения сервер выводит его на экран и отсылает обратное сообщение с типом 2 с фразой \code{OK}. Клиент получает ту же очередь, что и сервер и ждет ввода пользователя. Считав ввод, он шлет сообщение с типом 1, содержащее считанные данные и ожидает от сервера подтверждения о принятии сообщения.

\section{Количественные ограничения средств IPC}

Максимальные и минимальные значения констант можно выяснить вызывав команду \code{ipcs -l}:

\lstlogs{ipcs}

Из результатов видно, что по умолчанию размер одного сообщения не может быть больше 8192 байт, а очередь может содержаться не более 32000 сообщений.

\section{Семафоры и разделяемая память}

\paragraph{Задание.} Есть один процесс, выполняющий запись в разделяемую память и один процесс, выполняющий чтение из нее. Под чтением понимается извлечение данных из памяти. Программа должна обеспечить невозможность повторного чтения одних и тех же данных и невозможность перезаписи данных, т.е. новой записи, до тех пор, пока читатель не прочитает предыдущую.

В таком варианте задания для синхронизации процессов достаточно двух семафоров. Придадим одному из них смысл «запись разрешена», т.е. читатель предыдущие данные уже использовал; второму – «чтение разрешено», т.е. писатель уже сгенерировал новые данные, которые нужно прочитать. Оба семафора бинарные и используют стандартные операции, захват семафора – это ожидание освобождения ресурса (установки семафора в 1) и последующий захват ресурса (установки семафора в 0), освобождение ресурса -- это установка семафора в 1.

Используем \code{producer.c} как писателя, а \code{consumer.c} как читателя, а в \code{shm.h} вынесем константы, определение структуры \code{Message} и буферы для семафоров:

\lstheader{semaphore/shm}

\lstsrc{semaphore/consumer/consumer}

\lstsrc{semaphore/producer/producer}

Запустим \code{consumer} и \code{producer}:

\lstlogs{semaphore/consumer}

\lstlogs{semaphore/producer}

Из результатов видно, что все сообщения \code{producer} были успешно получены \code{consumer}.

\paragraph{Задание.} К условиям предыдущей задачи добавляется наличие не единичного буфера, а буфера некоторого размера. Тип буфера (очередь, стек, кольцевой буфер) не имеет значения.

Двух семафоров по-прежнему достаточно. Так как размер буфера не равен единице, то больше нет необходимости в чередовании операций чтения и записи, допустима ситуация нескольких записей подряд, и после этого нескольких чтений. Нужно только следить, чтобы не было записи в уже заполненный буфер и не было чтения из пустого буфера. Возьмем два считающих семафора. Максимальное значение обоих -- размер буфера. Первый инициализируется нулем и имеет смысл «количество заполненных ячеек», второй инициализируется \code{N}, где \code{N} -- размер буфера и имеет смысл «количество пустых ячеек». Операции записи-чтения становятся критическими секциями, доступ к которым также необходимо синхронизировать. Для этого будет достаточно еще одного бинарного семафора, имеющего смысл «доступ к памяти разрешен». Оба типа процессов должны захватывать его при попытке взаимодействия с памятью и освобождать после.

В качестве разделяемого ресурса используется массив, находящийся в разделяемой памяти, ячейка памяти, находящаяся за последним элементом массива интерпретируется как индекс последнего записанного элемента.

Используем \code{producer.c} как писателя, а \code{consumer.c} как читателя, а в \code{shm.h} вынесем константы, определение структуры \code{Message} и буферы для семафоров:

\lstheader{semaphores/shm}

\lstsrc{semaphores/consumer/consumer}

\lstsrc{semaphores/producer/producer}

Запустим читателя \code{consumer} и двух писателей \code{producer}:

\lstlogs{semaphores/consumer}

\lstlogs{semaphores/producer1}

\lstlogs{semaphores/producer2}

Процессы-писатели записывают по 10 чисел в массив, процесс-писатель считывает первые 15 из записанных. По результатам синхронизация работает корректно, выхода за пределы массива нет, записанные данные не затираются до их прочтения.

Для работы с участком разделяемой памяти, который используется как буфер единичного размера, достаточно двух бинарных семафоров: первый семафор используется, чтобы показать, что «запись разрешена»; второй используется, чтобы показать, что «чтение разрешено». В один момент времени записывать может только 1 писатель или считывать 1 читатель.

Для работы с участком разделяемой памяти, который используется как буфер не единичного размера, достаточно трех семафоров: первый имеет смысл «количество заполненных ячеек», второй - «количество пустых ячеек», третий – бинарный семафор, показывающий, что «доступ к памяти разрешен». Считающие семафоры нужны, чтобы следить, что есть пустые ячейки для записи и есть записанные данные для чтения. Бинарный семафор нужен, чтобы с памятью в один момент времени работал только 1 процесс.

\section{Сокеты}

\subsection{TCP}

\paragraph{Задание.} Сервер прослушивает заданный порт, при приходе нового соединения создается новый поток для его обработки. Работа с клиентом организована как бесконечный цикл, в котором выполняется прием сообщения от клиента, вывод его на экран и пересылка обратно клиенту.

Для взаимодействия используются TCP сокеты. Между сервером и клиентом устанавливается логическое соединение, при этом при получении данных из сокета с помощью вызова \code{recv}, есть вероятность получить сразу несколько сообщений, или не полностью прочитать сообщение. Поэтому для установления взаимной однозначности между отосланными и принятыми данными используются функции \code{recvFix} и \code{sendFix}. Принцип их работы следующий: функция \code{sendFix} перед посылкой собственно данных посылает «заголовок» - количество байт в посылке. Функция \code{recvFix} вначале принимает этот «заголовок», и вторым вызовом \code{recv} считывает переданное количество байт. Считать ровно то, количество байт, которое указанно в аргументе функции recv, позволяет флаг \code{MSG_WAITALL}. Если его не использовать и данных в буфере недостаточно, то будет прочитано меньшее количество.

\lstsrc{tcp/server/server}

\lstsrc{tcp/client/client}

\newpage

Запустим сервер \code{server} и двух клиентов \code{client}:

\lstlogs{tcp/server}

\lstlogs{tcp/client1}

\lstlogs{tcp/client2}

Видно, что из-за того что для каждого клиента создается отдельная нить на сервере, клиенты могут посылать запросы параллельно. Эхо-сервер успешно получает запросы и отправляет ответы, содержащие такой же текст сообщения.

\paragraph{Задание.} Модифицировать, если необходимо, предложенное приложение и реализовать обмен сервера с множеством клиентов. Количество клиентов: 10, 100, 1000.

Модифицируем клиентскую программу, сделав ее неинтерактивной. После запуска, клиент будет автоматически отправлять текст серверу раз в секунду. Напишем bash-скрипт, который будет запускать столько клиентских процессов, сколько будет передано аргументом.

\lstsrc{tcp/client/spamclient/spamclient}

\lstinputlisting[language=bash,caption=\code{start.sh}]{src/tcp/client/spamclient/start.sh}

При 10 и 100 клиентах сервер успешно обрабатывает запросы и отправляет ответы. 

При создании 1000 клиентов некоторые клиенты работают как обычно, но некоторым из приходят \code{RST}-ответы из-за чего вызов \code{recv()} оказывается неудачным: \code{Error while receiving after sending 'message from client 793': Connection reset by peer}. 

При создании 10000 клиентов на сервере заканчиваются ресурсы: \code{Error while creating new thread: Resource temporarily unavailable, counter = 2634}. Значение счетчика указывает на то, какое количество нитей жуе было создано к этому моменту.

\subsection{UDP}

Выполнить аналогичное взаимодействие на основе UDP.

\lstsrc{udp/server/server}

\lstsrc{udp/client/client}

Запустим сервер \code{server} и двух клиентов \code{client}:

\lstlogs{udp/server}

\lstlogs{udp/client1}

\lstlogs{udp/client2}

По результатам видно, что данные отправляются от клиента серверу и сервер успешно пересылает их обратно клиенту.

UDP использует простую модель передачи, без неявных «рукопожатий» для обеспечения надёжности, упорядочивания или целостности данных. Однако плюсом является то, что в нем соблюдаются границы пакета (максимум 65507 байт). Таким образом, UDP предоставляет ненадёжный сервис, и дейтаграммы могут прийти не по порядку, дублироваться или вовсе исчезнуть без следа. UDP подразумевает, что проверка ошибок и исправление либо не нужны, либо должны исполняться в приложении.

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item изучены различные типы средства межпроцессорного взаимодействия;
	\item рассмотрены надежные и ненадежные сигналы, а также сигналы реального времени;
	\item продемонстрированы возможности неименованных и именованных каналов и очереди сообщений;
	\item рассмотрено использование семафоров для синхронизации доступа к разделяемой памяти.
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Робачевский А. Операционная система UNIX [Текст] -- 2010.
	\item Уорд Б. Внутреннее устройство Linux [Текст] -- 2016.
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item Керриск М. - Linux API. Исчерпывающее руководство [Текст] -- 2018.
\end{enumerate}	

\newpage

\section*{Дополнения к отчету}

\subsection*{Сетевое межпроцессное взаимодействие}

В UNIX-подобных операционных системах все рассмотренные средства межпроцессного взаимодействия, за исключением сокетов, являются локальными, т.к. используют буферизацию в пространстве ядра и адресуются в локальном пространстве памяти. Поэтому рассмотрим сетевое взаимодействие на примере сокетов.

Будем использовать в эксперименте  ОС Ubuntu 18.04, установленную на ноутбук и ОС Ubunutu 18.10, установленную на виртуальной машине. Выведем информацию о системе и сети сначала в хостовой ОС, а затем в гостевой:

\lstlogs{remote/host}

\lstlogs{remote/virtualbox}

\noindent Таким образом в локальной сети хостовая ОС имеет IP-адрес \code{192.168.1.104}, а гостевая -- \code{192.168.1.102}.

Запустим в гостевой ОС TCP-север \code{tcp_server}, рассмотренную ранее. На хосте запустим несколько TCP-клиентов \code{tcp_client}, указав им параметром командной строки адрес и порт удаленного сервера.

\lstlogs{remote/server}

\lstlogs{remote/client1}

\lstlogs{remote/client2}

Видно, что сервер был запущен на порте по умолчанию (8888). Клиенты успешно подключились к указанному им в параметрах IP-адресу и порту и сделали по одному запросу. Сервер фиксировал событие и отправлял пришедшее сообщение обратно клиенту.

\subsection*{Подготовка тестового стенда}

Для тестирования сетевого взаимодействия было решено использовать виртуальную машину. Для этого с сайта Oracle VM VirtualBox\footnote{\url{https://www.virtualbox.org/wiki/Downloads}} была загружена версия для Linux. Затем с сайта Ubuntu\footnote{\url{https://www.ubuntu.com}} был загружен \code{.iso} образ операционной системы Ubuntu 18.10. 

После этого был создан экземпляр виртуальной машине, в качестве boot-образа был указан загруженный образ Ubuntu. Наконец, ОС была установлена и настроена.

\end{document}
