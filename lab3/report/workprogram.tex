\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}

\textbf{Порождение и запуск процессов}

\begin{enumerate}
	\item Создайте программу на основе одного исходного (а затем исполняемого) файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка.
	\item Выполните сначала однократные вычисления в каждом процессе, обратите внимание, какой процесс на каком этапе владеет процессорным ресурсом. Каждый процесс должен иметь вывод на терминал, идентифицирующий текущий процесс. Последняя исполняемая команда функции \code{main} должна вывести на терминал сообщение о завершении программы. Объясните результаты. Сделайте выводы об использовании адресного пространства.
	\item Затем однократные вычисления замените на циклы, длительность исполнения которых достаточна для наблюдения конкуренции процессов за процессорный ресурс.
	\item Измените процедуру планирования и повторите эксперимент.
	\item Разработайте программы родителя и потомка с размещением в файлах \code{father.c} и \code{son.c}. Для фиксации состояния таблицы процессов в файле целесообразно использовать системный вызов \code{system("ps -abcde > file")}.
	\item Запустите на выполнение программу \code{father.out}, получите информацию о процессах, запущенных с вашего терминала.
	\item Выполните программу \code{father.out} в фоновом режиме \code{father \&}. Получите таблицу процессов, запущенных с вашего терминала (включая отцовский и сыновний процессы).
	\item Выполните создание процессов с использованием различных функций семейства exec() с разными параметрами функций семейства, приведите результаты эксперимента.
	\item  Проанализируйте значение, возвращаемое функцией wait(\&status). Предложите эксперимент, позволяющий родителю отслеживать подмножество порожденных потомков, используя различные функции семейства \code{wait()}.
	\item Проанализируйте очередность исполнения процессов.
		\begin{enumerate}
			\item Очередность исполнения процессов, порожденных вложенными вызовами \code{fork()}.
			\item Измените процедуру планирования с помощью функции с шаблоном \code{scheduler} в ее названии и повторите эксперимент.
			\item Поменяйте порядок очереди в RR-процедуре. 10.4. Можно ли задать разные процедуры планирования разным процессам с одинаковыми приоритетами. Как они будут конкурировать, подтвердите экспериментально.
		\end{enumerate}
	\item  Определите величину кванта. Можно ли ее поменять? – для обоснования проведите эксперимент.
	\item  Проанализируйте наследование на этапах \code{fork()} и \code{exec()}. Проведите эксперимент с родителем и потомками по доступу к одним и тем же файлам, открытым родителем. Аналогичные эксперименты проведите по отношению к другим параметрам. 
\end{enumerate}

\textbf{Взаимодействие родственных процессов}

\begin{enumerate}
	\setcounter{enumi}{12}
	\item Проанализируйте взаимодействие родственных процессов:
		\begin{enumerate}
			\item Изменяя длительности выполнения процессов и параметры
			системных вызовов, рассмотрите 3 ситуации и получите соответствующие
			таблицы процессов:
				\begin{itemize}
					\item процесс-отец запускает процесс-сын и ожидает его завершения;
					\item процесс-отец запускает процесс-сын и, не ожидая его завершения,
					завершает свое выполнение. Зафиксируйте изменение родительского
					идентификатора процесса-сына;
					\item процесс-отец запускает процесс-сын и не ожидает его завершения;
					процесс-сын завершает свое выполнение. Зафиксируйте появление
					процесса-зомби, для этого включите команду ps в программу father.c
				\end{itemize}

			\item Перенаправьте вывод не только на терминал, но и в файл.
			Организуйте программу многопроцессного функционирования так, чтобы
			результатом ее работы была демонстрация всех трех ситуаций с
			отображением в итоговом файле.
		\end{enumerate}
\end{enumerate}

\textbf{Управление процессами посредством сигналов}

\begin{enumerate}
	\setcounter{enumi}{13}
	\item Проанализируйте управление процессами посредством сигналов:
		\begin{enumerate}
			\item С помощью команды \code{kill -l} ознакомьтесь с перечнем сигналов поддерживаемых процессами. Ознакомьтесь с системными вызовами \code{kill(2)}, \code{signal(2)}. Подготовьте программы следующего содержания:
				\begin{itemize}
					\item процесс \code{father} порождает процессы \code{son1}, \code{son2}, \code{son3} и запускает на исполнение программные коды из соответствующих исполнительных файлов;
					\item далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу;
					\item в пользовательских процессах-потомках необходимо обеспечить: \\для son1 - реакцию на сигнал по умолчанию; \\для son2 - реакцию игнорирования; \\для son3 - перехватывание и обработку сигнала.
				\end{itemize}
			Сформируйте файл-проект из четырех файлов, откомпилируйте, запустите программу. Проанализируйте таблицу процессов до и после посылки сигналов с помощью системного вызова system("ps -s >> file"). Обратите внимание на реакцию, устанавливаемую для последнего
			потомка.
			\item Организуйте посылку сигналов любым двум процессам, находящимся в разных состояниях: активном и пассивном, фиксируя моменты посылки и приема каждого сигнала с точностью до секунды. Приведите результаты в файле результатов.
		\end{enumerate}
	\item Запустите в фоновом режиме несколько утилит, например: \code{cat *.c > myprog \& lpr myprog \& lpr intro\&}. Воспользуйтесь командой jobs для анализа списка заданий и очередности их выполнения. Позаботьтесь об уведомлении о завершении одного из заданий с помощью команды notify. Аргументом команды является номер задания. Верните невыполненные задания в приоритетный режим командой fg. Например: \code{fg \%3} Отмените одно из невыполненных заданий.
	\item Ознакомьтесь с выполнением команды и системного вызова \code{nice(1)} и \code{getpriority(2)}. Приведите примеры их использования в приложении. Определите границы приоритетов (создайте для этого программу). Есть ли разница в приоритетах для системных и пользовательских процессов, используются ли приоритеты реального времени? Каков пользовательский приоритет для запуска приложений из shell? Все ответы подкрепляйте экспериментально.
	\item Ознакомьтесь с командой \code{nohup(1)}. Запустите длительный процесс по \code{nohup(1)}. Завершите сеанс работы. Снова войдите в систему и проверьте таблицу процессов. Поясните результат.
	\item Определите UID процесса, каково минимальное значение и кому оно принадлежит. Каково минимальное и максимальное значение PID, каким процессам принадлежат? Проанализируйте множество системных процессов, как их отличить от прочих, перечислите назначение самых важных из них.
\end{enumerate}

\textbf{Многонитевое функционирование}

\begin{enumerate}
	\setcounter{enumi}{18}
	\item Подготовьте программу, формирующую несколько нитей. Нити для эксперимента могут быть практически идентичны. Например, каждая нить в цикле: выводит на печать собственное имя и инкрементирует переменную времени, после чего "засыпает" (\code{sleep(5);}, \code{sleep(1);} -- для первой и второй нитей соответственно), на экран (в файл) должно выводиться имя нити и количество пятисекундных (для первой) и секундных (для второй) интервалов функционирования каждой нити.
	\item После запуска программы проанализируйте выполнение нитей, распределение во времени Используйте для этого вывод таблицы процессов командой \code{ps -axhf}. Попробуйте удалить нить, зная ее идентификатор, командой \code{kill}.Приведите и объясните результат.
	\item Модифицируйте программу так, чтобы управление второй нитью осуществлялось посредством сигнала \code{SIGUSR1} из первой нити. На пятой секунде работы приложения удалите вторую нить. Для этого воспользуйтесь функцией \code{pthread\_kill(t2, SIGUSR);} (\code{t2} -- дескриптор второй нити). В остальном программу можно не изменять. Проанализируйте полученные
	результаты.
	\item Последняя модификация предполагает создание собственного обработчика сигнала, содержащего уведомление о начале его работы и возврат посредством функции \code{pthread\_exit(NULL);}. Сравните результаты, полученные после запуска этой модификации программы с результатами предыдущей.
	\item Перехватите сигнал <<CTRL-C>> для процесса и потока однократно, а также многократно с восстановлением исходного обработчика после нескольких раз срабатывания. Проделайте аналогичную работу для переназначения другой комбинации клавиш.
	\item С помощью утилиты \code{kill} выведите список всех сигналов и дайте их краткую характеристику на основе документации ОС. Для чего предназначены сигналы с 32 по 64-й. Приведите пример их применения.
	\item Проанализируйте процедуру планирования для процессов и потоков одного процесса. 
		\begin{enumerate}
			\item Обоснуйте результат экспериментально.
			\item Попробуйте процедуру планирования изменить. Подтвердите экспериментально, если изменение возможно.
			\item Задайте нитям разные приоритеты программно и извне (объясните результат). 
		\end{enumerate}
\end{enumerate}