\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

\begin{itemize}
	\item раз
	\item два
\end{itemize}

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Порождение и запуск процессов}

\subsection{Порождение процесса потомка}

Создадим программу на основе одного исходного файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка. Для создания копии текущего процесса используется системный вызов \code{fork}.
\lstinputlisting[caption=\code{fork.c}]{1_fork/fork.c}

После выполнения \code{fork} оба процесса продолжают выполнение с одной и той же точки. \code{fork} возвращает в породивший процесс идентификатор порожденного
процесса (\code{PID}), а в порожденный процесс -- \code{NULL}. В случае, если новый процесс не может быть порожден, возвращаемое значение равно \code{-1}.

\lstinputlisting{1_fork/log}

Из результатов выполнения видно, что Parent \code{PID} (\code{PPID}) дочернего процесса равен \code{PID} родительского процесса.

При выполнении однократных вычислений в каждом процессе после порождения дочернего потока, родительский поток продолжает выполнение (печать и завершение), и лишь после этого начинает выполнятся порожденный процесс.

%TODO Объясните результаты. Сделайте выводы об использовании адресного пространства.

\subsection{Конкуренция за процессорный ресурс}

Если заменить однократные вычисления на циклы, длительность исполнения которых достаточна велика, можно наблюдать за конкуренцией между процессами за процессорный ресурс. 

\lstinputlisting[caption=\code{fight.c}]{3_fight/fight.c}

Программа выполняет вызов \code{fork}, выводит идентификатор выполняющегося процесса. В случае, если текущий процесс является потомком, то производится 1000 операций инкрементации переменной \code{n}, иначе (процесс является родителем) -- 1000 операций декремента переменной \code{m}. После завершения вычислений, выводится результат и сообщение о завершении вычислений.

\lstinputlisting{3_fight/log}

Из результатов видно, что сначала полностью выполняется родитель и лишь после этого начинает выполнятся потомок.

\subsection{Изменение процедуры планирования}

Повторим эксперимент с конкуренцией за процессорный ресурс, изменив при этом процедуру планирования, добавив вызов \code{usleep(1)} после каждой итерации.

\lstinputlisting[caption=\code{fight\_sleep.c}]{4_fight_sleep/fight_sleep.c}

Из результатов видно, что теперь процессы выполняются поочередно, при этом не определен порядок завершения их вычислений: при некоторых запусках родительский процесс завершится раньше, а при некоторых -- дочерний.

\lstinputlisting{4_fight_sleep/log}

\subsection{Размещение родителя и потомка в разных файлах}
\label{sec:father-son}

Разработаем программы родителя и потомка с размещением в файлах \code{father.c} и \code{son.c}. Для фиксации состояния таблицы процессов в файле будем использовать системный вызов \code{system("ps xf > dump.txt")}.

\lstinputlisting[caption=\code{father.c}]{5_father_son/father.c}

\lstinputlisting[caption=\code{son.c}]{5_father_son/son.c}

\lstinputlisting{5_father_son/log}

Из сохраняемого в файл \code{dump.txt} дерева процессов видно, что процесс \code{./parent} является родительским для \code{son}, что подтверждает выводимая в консоль информация о \code{PID} и \code{PPID} каждого из процессов.

\lstinputlisting{5_father_son/tree1}

При выполнении \code{./father \&} интерпретатор запускает \code{father} в фоновом режиме, а параллельно ей запускается команда \code{ps -xf}. При завершении \code{father} добавляется строка \code{[1]+ Done}.

\lstinputlisting{5_father_son/tree2}

\subsection{Использование функций семейства \code{exec}}

Для демонстрации использования разных функций семейства используем программу \code{exec.c}, в которой на примере утилиты \code{ls} показаны различия и возможности всех функций семейства.

\lstinputlisting[caption=\code{exec.c}]{8_exec/exec.c}

Вывод программы при различных значениях первого аргумента (\code{1} -- \code{6}) идентичен, а отличия составляет лишь способ вызова функции семейства \code{exec}. Суффиксы функций при этом означают:
\begin{itemize}
	\item \code{l} (list) -- аргументы командной строки передаются в форме списка \code{arg0}, \code{arg1}, \dots, \code{argN}, \code{NULL};
	\item \code{v} (vector) -- аргументы командной строки передаются в форме вектора \code{argv[]};
	\item \code{p} (path) -- обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды \code{PATH};
	\item \code{e} (environment) -- функция ожидает список переменных окружения в виде вектора \code{env[]}.
\end{itemize}

\subsection{Использование функций семейства \code{wait}}

Выполнение порождающего процесса может быть приостановлено до завершения потомка системным вызовом \code{wait}. Системный вызов \code{wait} возвращает родителю идентификатор того потомка, который завершился первым после последнего обращения к \code{wait}. Например, при выполнении программы в разделе \ref{sec:father-son} возвращаемое значение оказалось равно нулю. 

Для демонстрации использования функции \code{waitpid} используем программы \code{father\_wait.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Родительский процесс порождает 3 потомков, после чего ожидает их завершения (вызывая функцию \code{waitpid} с различными флагами). Дочерние процессы завершаются с кодом \code{0}, \code{1} и \code{-1} соответственно. После завершения всех порожденных процессов предок выводит информацию о завершении каждого процесса.

\lstinputlisting[caption=\code{father.c}]{9_wait/father.c}

\lstinputlisting[caption=\code{son1.c}]{9_wait/son1.c}

\lstinputlisting[caption=\code{son2.c}]{9_wait/son2.c}

\lstinputlisting[caption=\code{son3.c}]{9_wait/son3.c}

При вызове функции \code{waitpid} с параметрами \code{WNOHANG}, \code{WUNTRACED} и \code{WNOHANG} соответственно неуспешно завершился только вызов \code{waiapid} для первого процесса, т.к. он к моменту вызова \code{waitpid} с опцией \code{WNOHANG} еще не был завершен (при использовании опции \code{WNOHANG} управление возвращается сразу, если потомок еще не завершен).

\lstinputlisting{9_wait/log1}
 
\subsection{Политики планирования}

В системах, следующих стандарту POSIX поддерживается три базовые политики планирования:
\begin{itemize}
	\item \code{SCHED\_FIFO} -- планировщик FIFO;
	\item \code{SCHED\_RR} -- циклический алгоритм планирования;
	\item \code{SCHED\_OTHER} -- стандартный алгоритм планировщика с	разделением времени.
\end{itemize}

Для удобства исследования политик планирования создадим файлы \code{utils.h} и \code{utils.c}, содержащие декларации и определения функций \code{print\_parameters} (печать PID и PPID), \code{print\_current\_priority} (печать политики и приоритета выполняемого процесса) и \code{set\_priority} (установка политики и приоритета процесса в зависимости от передаваемых параметров).

\lstinputlisting[caption=\code{utils.h}]{10_scheduler/utils.h}

\lstinputlisting[caption=\code{utils.c}]{10_scheduler/utils.c}

\subsubsection{Наследование политики планирования и приоритета}

Для анализа наследования политики планирования и приоритета исполнения процессов используем программы \code{father.c} и \code{son.c}.

\lstinputlisting[caption=\code{father.c}]{10_scheduler/father.c}

\lstinputlisting[caption=\code{son.c}]{10_scheduler/son.c}

При попытке исполнения программы от имени обычного пользователя, появляется сообщение об ошибке – о том, что операция изменения приоритета запрещена. При выполнении от имени суперпользователя программа работает корректно.

\lstinputlisting{10_scheduler/log1}

Из результатов видно, что потомки наследуют политику планирования и приоритет родительского процесса.

\subsubsection{Очередность исполнения процессов, порожденных вложенными вызовами \code{fork()}}

Проанализируем очередность исполнения процессов, порожденных вложенными вызовами \code{fork}. Для этого создадим файл \code{nesting.c}, который порождает процесс (\code{son1}), внутри которого порождается еще один процесс (\code{son2}). Кроме того, в данном и последующих случаях нам необходимо, чтобы было использовано одно ядро процессора (чтобы контролировать планирование процессов). Для этого воспользуемся командой \code{taskset -c 1 ./program}, которая ограничивает количество используемых ядер при выполнении программы \code{./program}.

\lstinputlisting[caption=\code{nesting.c}]{10_scheduler/nesting.c}

\lstinputlisting{10_scheduler/log2}

Из результатов видно, что процессы выполняются в порядке их порождения (от самого внешнего процесса -- родительского, до самого вложенного).

\subsubsection{Изменение процедуры планирования}

На основе \code{son.c} создадим файл \code{son\_calc.c}, внутри которой будем выполнять вычисления (увеличивать счетчик до миллиона), периодически сохраняя текущее время. После вычислений программа распечатывает список сохраненных времен. На основе этого списка можно будет сделать вывод о том, какой из процессов получил больший приоритет при планировании. 

\lstinputlisting[caption=\code{son\_calc.c}]{10_scheduler/son_calc.c}

Создадим программу \code{father\_priority.c}, которая будет порождать три процесса \code{son\_calc} с параметрами планирования, полученными через аргументы командой строки. 

\lstinputlisting[caption=\code{father\_priority.c}]{10_scheduler/father_priority.c}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_RR}. Видно, что так как приоритеты равны, то все три процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log3}

Приведем результаты с отличающимися приоритетами процессов (один из приоритетов больше двух других) и политикой \code{SCHED\_RR}. Видно, что сначала выполняется процесс с большим приоритетом, после чего два оставшихся процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log4}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что так как приоритеты равны, процессы не были заблокированы запросами на ввод/вывод и не была вызвана функция \code{sched\_yield}, то все три процесса выполняются друг за другом (следующий начинает выполняться только после полного завершения предыдущего).
\lstinputlisting{10_scheduler/log5}

Приведем результаты с отличающимися приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что сначала выполняется процесс с большим приоритетом (30), после чего выбирается процесс с большим приоритетом среди оставшихся (20), после чего выполняется последний (10).
\lstinputlisting{10_scheduler/log6}

Зададим разным процессам разные процедуры планирования с одинаковыми приоритетами. Для этого процесс \code{son1} будем запускать с процедурой планирования \code{SCHED\_FIFO} вне зависимости от входных данных.
\lstinputlisting{10_scheduler/log7}
Из листинга видно, что сначала была выбрана процедура планирования \code{SCHED\_RR} и все процессы получили по кванту времени, а когда выполнение дошло до процесса с политикой \code{SCHED\_FIFO}, он захватил процессор. Оставшиеся процессы продолжили выполнение только после завершения процесса с политикой \code{SCHED\_FIFO}.

\subsubsection{Определение величины кванта}

Для определения величины кванта используем программу \code{interval.c}. Политика планирования задается с помощью аргумента командой строки.

\lstinputlisting[caption=\code{interval.c}]{10_scheduler/interval.c}

Из результатов запуска программы видно, что при политике планирования \code{SCHED\_RR} величина кванта равна 0.1 секунды, при \code{SCHED\_FIFO} -- 0 секунд, а при \code{SCHED\_OTHER} -- 0.02 секунды.

\lstinputlisting{10_scheduler/log8}

\subsection{Наследование на этапах \code{fork()} и \code{exec()}}

\section{Взаимодействие родственных процессов}

\section{Управление процессами посредством сигналов}

\section{Многонитевое функционирование}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item раз
	\item два
\end{itemize}


\end{document}
