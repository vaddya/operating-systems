\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

\begin{itemize}
	\item Изучить основные принципы порождения и управления процессами и нитями в ОС UNIX на примере ОС Linux.
	\item Проанализировать использование функций семейства \code{exec} и \code{wait}. 
	\item Познакомиться с одним из видов IPC -- сигналами.
\end{itemize}

\section{Программа работы}

\input{workprogram}

\newpage

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Порождение и запуск процессов}

\subsection{Порождение процесса потомка}

Создадим программу на основе одного исходного файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка. Для создания копии текущего процесса используется системный вызов \code{fork}.
\lstinputlisting[caption=\code{fork.c}]{1_fork/fork.c}

После выполнения \code{fork} оба процесса продолжают выполнение с одной и той же точки. \code{fork} возвращает в породивший процесс идентификатор порожденного
процесса (\code{PID}), а в порожденный процесс -- \code{NULL}. В случае, если новый процесс не может быть порожден, возвращаемое значение равно \code{-1}.

\lstinputlisting{1_fork/log}

Из результатов выполнения видно, что Parent \code{PID} (\code{PPID}) дочернего процесса равен \code{PID} родительского процесса.

При выполнении однократных вычислений в каждом процессе после порождения дочернего потока, родительский поток продолжает выполнение (печать и завершение), и лишь после этого начинает выполнятся порожденный процесс.

\subsection{Конкуренция за процессорный ресурс}

Если заменить однократные вычисления на циклы, длительность исполнения которых достаточна велика, можно наблюдать за конкуренцией между процессами за процессорный ресурс. 

\lstinputlisting[caption=\code{fight.c}]{3_fight/fight.c}

Программа выполняет вызов \code{fork}, выводит идентификатор выполняющегося процесса. В случае, если текущий процесс является потомком, то производится 1000 операций инкрементации переменной \code{n}, иначе (процесс является родителем) -- 1000 операций декремента переменной \code{m}. После завершения вычислений, выводится результат и сообщение о завершении вычислений.

\lstinputlisting{3_fight/log}

Из результатов видно, что сначала полностью выполняется родитель и лишь после этого начинает выполнятся потомок.

\subsection{Изменение процедуры планирования}

Повторим эксперимент с конкуренцией за процессорный ресурс, изменив при этом процедуру планирования, добавив вызов \code{usleep(1)} после каждой итерации.

\lstinputlisting[caption=\code{fight\_sleep.c}]{4_fight_sleep/fight_sleep.c}

Из результатов видно, что теперь процессы выполняются поочередно, при этом не определен порядок завершения их вычислений: при некоторых запусках родительский процесс завершится раньше, а при некоторых -- дочерний.

\lstinputlisting{4_fight_sleep/log}

\subsection{Размещение родителя и потомка в разных файлах}
\label{sec:father-son}

Разработаем программы родителя и потомка с размещением в файлах \code{father.c} и \code{son.c}. Для фиксации состояния таблицы процессов в файле будем использовать системный вызов \code{system("ps xf > dump.txt")}.

\lstinputlisting[caption=\code{father.c}]{5_father_son/father.c}

\lstinputlisting[caption=\code{son.c}]{5_father_son/son.c}

\lstinputlisting{5_father_son/log}

Из сохраняемого в файл \code{dump.txt} дерева процессов видно, что процесс \code{./parent} является родительским для \code{son}, что подтверждает выводимая в консоль информация о \code{PID} и \code{PPID} каждого из процессов.

\lstinputlisting{5_father_son/tree1}

При выполнении \code{./father \&} интерпретатор запускает \code{father} в фоновом режиме, а параллельно ей запускается команда \code{ps -xf}. При завершении \code{father} добавляется строка \code{[1]+ Done}.

\lstinputlisting{5_father_son/tree2}

\subsection{Использование функций семейства \tcode{exec}}

Для демонстрации использования разных функций семейства используем программу \code{exec.c}, в которой на примере утилиты \code{ls} показаны различия и возможности всех функций семейства.

\lstinputlisting[caption=\code{exec.c}]{8_exec/exec.c}

Вывод программы при различных значениях первого аргумента (\code{1} -- \code{6}) идентичен, а отличия составляет лишь способ вызова функции семейства \code{exec}. Суффиксы функций при этом означают:
\begin{itemize}
	\item \code{l} (list) -- аргументы командной строки передаются в форме списка \code{arg0}, \code{arg1}, \dots, \code{argN}, \code{NULL};
	\item \code{v} (vector) -- аргументы командной строки передаются в форме вектора \code{argv[]};
	\item \code{p} (path) -- обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды \code{PATH};
	\item \code{e} (environment) -- функция ожидает список переменных окружения в виде вектора \code{env[]}.
\end{itemize}

\subsection{Использование функций семейства \tcode{wait}}

Выполнение порождающего процесса может быть приостановлено до завершения потомка системным вызовом \code{wait}. Системный вызов \code{wait} возвращает родителю идентификатор того потомка, который завершился первым после последнего обращения к \code{wait}. Например, при выполнении программы в разделе \ref{sec:father-son} возвращаемое значение оказалось равно нулю. 

Для демонстрации использования функции \code{waitpid} используем программы \code{father\_wait.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Родительский процесс порождает 3 потомков, после чего ожидает их завершения (вызывая функцию \code{waitpid} с различными флагами). Дочерние процессы завершаются с кодом \code{0}, \code{1} и \code{-1} соответственно. После завершения всех порожденных процессов предок выводит информацию о завершении каждого процесса.

\lstinputlisting[caption=\code{father.c}]{9_wait/father.c}

\lstinputlisting[caption=\code{son1.c}]{9_wait/son1.c}

\lstinputlisting[caption=\code{son2.c}]{9_wait/son2.c}

\lstinputlisting[caption=\code{son3.c}]{9_wait/son3.c}

При вызове функции \code{waitpid} с параметрами \code{WNOHANG}, \code{WUNTRACED} и \code{WNOHANG} соответственно неуспешно завершился только вызов \code{waiapid} для первого процесса, т.к. он к моменту вызова \code{waitpid} с опцией \code{WNOHANG} еще не был завершен (при использовании опции \code{WNOHANG} управление возвращается сразу, если потомок еще не завершен).

\lstinputlisting{9_wait/log1}
 
\subsection{Политики планирования}

В системах, следующих стандарту POSIX поддерживается три базовые политики планирования:
\begin{itemize}
	\item \code{SCHED\_FIFO} -- планировщик FIFO;
	\item \code{SCHED\_RR} -- циклический алгоритм планирования;
	\item \code{SCHED\_OTHER} -- стандартный алгоритм планировщика с	разделением времени.
\end{itemize}

Для удобства исследования политик планирования создадим файлы \code{utils.h} и \code{utils.c}, содержащие декларации и определения функций \code{print\_parameters} (печать PID и PPID), \code{print\_current\_priority} (печать политики и приоритета выполняемого процесса) и \code{set\_priority} (установка политики и приоритета процесса в зависимости от передаваемых параметров).

\lstinputlisting[caption=\code{utils.h}]{10_scheduler/utils.h}

\lstinputlisting[caption=\code{utils.c}]{10_scheduler/utils.c}

\subsubsection{Наследование политики планирования и приоритета}

Для анализа наследования политики планирования и приоритета исполнения процессов используем программы \code{father.c} и \code{son.c}.

\lstinputlisting[caption=\code{father.c}]{10_scheduler/father.c}

\lstinputlisting[caption=\code{son.c}]{10_scheduler/son.c}

При попытке исполнения программы от имени обычного пользователя, появляется сообщение об ошибке – о том, что операция изменения приоритета запрещена. При выполнении от имени суперпользователя программа работает корректно.

\lstinputlisting{10_scheduler/log1}

Из результатов видно, что потомки наследуют политику планирования и приоритет родительского процесса.

\subsubsection{Очередность исполнения процессов, порожденных вложенными вызовами \tcode{fork()}}

Проанализируем очередность исполнения процессов, порожденных вложенными вызовами \code{fork}. Для этого создадим файл \code{nesting.c}, который порождает процесс (\code{son1}), внутри которого порождается еще один процесс (\code{son2}). Кроме того, в данном и последующих случаях нам необходимо, чтобы было использовано одно ядро процессора (чтобы контролировать планирование процессов). Для этого воспользуемся командой \code{taskset -c 1 ./program}, которая ограничивает количество используемых ядер при выполнении программы \code{./program}.

\lstinputlisting[caption=\code{nesting.c}]{10_scheduler/nesting.c}

\lstinputlisting{10_scheduler/log2}

Из результатов видно, что процессы выполняются в порядке их порождения (от самого внешнего процесса -- родительского, до самого вложенного).

\subsubsection{Изменение процедуры планирования}

На основе \code{son.c} создадим файл \code{son\_calc.c}, внутри которой будем выполнять вычисления (увеличивать счетчик до миллиона), периодически сохраняя текущее время. После вычислений программа распечатывает список сохраненных времен. На основе этого списка можно будет сделать вывод о том, какой из процессов получил больший приоритет при планировании. 

\lstinputlisting[caption=\code{son\_calc.c}]{10_scheduler/son_calc.c}

Создадим программу \code{father\_priority.c}, которая будет порождать три процесса \code{son\_calc} с параметрами планирования, полученными через аргументы командой строки. 

\lstinputlisting[caption=\code{father\_priority.c}]{10_scheduler/father_priority.c}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_RR}. Видно, что так как приоритеты равны, то все три процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log3}

Приведем результаты с отличающимися приоритетами процессов (один из приоритетов больше двух других) и политикой \code{SCHED\_RR}. Видно, что сначала выполняется процесс с большим приоритетом, после чего два оставшихся процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log4}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что так как приоритеты равны, процессы не были заблокированы запросами на ввод/вывод и не была вызвана функция \code{sched\_yield}, то все три процесса выполняются друг за другом (следующий начинает выполняться только после полного завершения предыдущего).
\lstinputlisting{10_scheduler/log5}

Приведем результаты с отличающимися приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что сначала выполняется процесс с большим приоритетом (30), после чего выбирается процесс с большим приоритетом среди оставшихся (20), после чего выполняется последний (10).
\lstinputlisting{10_scheduler/log6}

Зададим разным процессам разные процедуры планирования с одинаковыми приоритетами. Для этого процесс \code{son1} будем запускать с процедурой планирования \code{SCHED\_FIFO} вне зависимости от входных данных.
\lstinputlisting{10_scheduler/log7}
Из листинга видно, что сначала была выбрана процедура планирования \code{SCHED\_RR} и все процессы получили по кванту времени, а когда выполнение дошло до процесса с политикой \code{SCHED\_FIFO}, он захватил процессор. Оставшиеся процессы продолжили выполнение только после завершения процесса с политикой \code{SCHED\_FIFO}.

\subsubsection{Определение величины кванта}

Для определения величины кванта используем программу \code{interval.c}. Политика планирования задается с помощью аргумента командой строки.

\lstinputlisting[caption=\code{interval.c}]{10_scheduler/interval.c}

Из результатов запуска программы видно, что при политике планирования \code{SCHED\_RR} величина кванта равна 0.1 секунды, при \code{SCHED\_FIFO} -- 0 секунд, а при \code{SCHED\_OTHER} -- 0.02 секунды.

\lstinputlisting{10_scheduler/log8}

\subsection{Наследование на этапах \tcode{fork()} и \tcode{exec()}}

Проанализируем наследование на этапах \code{fork()} и \code{exec()}. Для этого проведем эксперимент по проверке доступа потомков к файлам, открытым породившим их процессом. Рассмотрим пример кода, в котором в качестве аргументов процессам-потомкам передаются дескрипторы открытого и созданного родительским процессом файлов (в данном примере это \code{input.txt} и \code{output.txt} соответственно).

Порожденные процессы независимо друг от друга вызывают функции \code{read} и \code{write}, и в цикле считывают по одному байту информацию из исходного файла и переписывают ее в файл вывода. Для того чтобы пронаблюдать одновременный доступ порожденных процессов к файлам, добавим вызов \code{sched\_yield()} после вывода каждого символа. Данный вызов ставит процесс в конец очереди процессов с одинаковым статическим приоритетом.

\lstinputlisting[caption=\code{father.c}]{11_inheritance/father.c}

\lstinputlisting[caption=\code{son.c}]{11_inheritance/son.c}

Результат выполнения программы:

\lstinputlisting{11_inheritance/log}

Видно, что дескрипторы \code{fdrd} в обоих потомках указывают на запись в таблице файлов, соответствующую исходному файлу, а дескрипторы, подставляемые в качестве \code{fdwr}, на запись, соответствующую  вывода.

Ядро смещает внутрифайловые указатели после каждой операции чтения или записи, поэтому порожденные процессы никогда не обращаются вместе на чтение или запись по одному и тому же указателю или смещению внутри файла (из двух процессов-потомков считать одни и те же данные нельзя, только если заново открывать файл). В результате выполнения в выходной файл записалось содержимое входного файла.

Рассмотрим наследование остальных параметров при порождении потомков. Для этого запустим \code{father} в фоновом режиме и выполним команду \code{ps -e -o uid,gid,ruid,pid,ppid,pgid,tty,vsz,stat,command > tree}.

\lstinputlisting{11_inheritance/tree}

Из содержимого файла \code{tree} видно, что от родителя наследуются UID, GID, RUID, PGID, TTY. Ранее на экспериментах было показано, что также наследуются приоритеты и политика планирования.

\section{Взаимодействие родственных процессов}

Родственными считаются процессы, ближайшие в дереве процессов, т.е. породивший и порожденные им процессы. Их взаимодействие основывается на наследовании и существенно проще по сравнению с взаимодействием независимых процессов, поскольку независимые процессы полностью изолированы друг от друга и нуждаются в посреднике при обмене информацией в виде ядра ОС. 

Для наблюдения за взаимодействием родственных процессов создадим программы \code{father.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}.

\lstinputlisting[caption=\code{father.c}]{12_interaction/father.c}

\lstinputlisting[caption=\code{son1.c}]{12_interaction/son1.c}

\lstinputlisting[caption=\code{son2.c}]{12_interaction/son2.c}

\lstinputlisting[caption=\code{son3.c}]{12_interaction/son3.c}

Полученные результаты:
\begin{enumerate}
	\item Родитель порождает \code{son1} и дожидается его завершения. 
	\item В программе \code{son2} для увеличения длительности существования потомка используется задержка 10 секунд. В результате более раннего завершения родителя потомок становится наследником процесса \code{systemd} (\code{PID} = 2015). Из результатов видно, что как только родительский процесс завершается, на консоли сразу же появляется приглашение на ввод команды. Но так как время выполнения \code{son2} больше, результат выполнения son2 появляется уже после приглашения.
	\item Родитель порождает \code{son3} и не ожидает его завершения. В таком случае процесс получает статус zombie (процесс остается формально существующим, но ресурсы, отведенные для него, освобождаются).
\end{enumerate}

\lstinputlisting[deletekeywords={for}]{12_interaction/log}

\lstinputlisting{12_interaction/tree}

Из дерева процессов видно, что \code{son1} выполнился нормально, \code{son2} сменил родителя и перешел в <<самостоятельную>> ветку, \code{son3} оказался в состоянии zombie (\code{<defunct>}).

\section{Управление процессами посредством сигналов}

Сигналы позволяют осуществить самый примитивный способ
коммуникации между двумя процессами. Сигналы в системе UNIX  используются для того, чтобы сообщить процессу о том, что возникло какое-либо событие или необходимо обработать
исключительное состояние. 

С помощью команды \code{singal -l} получим список поддерживаемых сигналов. Сигналы 1 -- 31 являются базовыми, а остальные -- расширенными.

\lstinputlisting{13_signals/list}

\subsection{Генерация и реагирование на сигналы}

Для изучения генерации и реагирования на сигналы используем программу \code{father.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Процесс \code{father} порождает процессы \code{son1}, \code{son2}, \code{son3} и запускает на исполнение программные коды из соответствующих исполнительных файлов. Далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу. Процесс \code{son1} реагирует на сигнал по умолчанию, \code{son2} -- игнорирует сигнал, а \code{son3} -- перехватывает и обрабатывает сигнал.

\lstinputlisting[caption=\code{father.c}]{13_signals/father.c}

\lstinputlisting[caption=\code{son1.c}]{13_signals/son1.c}

\lstinputlisting[caption=\code{son2.c}]{13_signals/son2.c}

\lstinputlisting[caption=\code{son3.c}]{13_signals/son3.c}

Приведем результаты выполнения программы \code{father} и файл \code{signals}, содержащий информацию о сигналах, полученную с помощью вызова \code{ps -s}.

\lstinputlisting{13_signals/log1}

\lstinputlisting{13_signals/signals}

Из результатов видно, что:
\begin{itemize}
	\item порожденный процесс \code{son1}, установивший обработчик по умолчанию, был прерван и не был завершен;
	\item порожденный процесс \code{son2}, установивший игнорирование сигнала, не был прерван сигналом. В поле \code{IGNORED} установлено значение \code{2}, обозначающее номер игнорируемого сигнала (\code{SIGINT});
	\item порожденный процесс \code{son3}, установивший свой обработчик сигнала, был прерван и был вызван установленный обработчик, после чего выполнение программы продолжилось. В поле \code{CAUGHT} установлено значение \code{2}, обозначающее номер перехватываемого сигнала (\code{SIGINT}).
\end{itemize}

\subsection{Посылка сигналов процессам в активном и пассивном состоянии}

Для анализа различий обработки сигналов в зависимости от состояния процесса создадим программы \code{father\_active\_passive.c}, \code{son\_active.c} и \code{son\_passive.c}. Порождаемые процессы отличаются состоянием: после инициализации активный процесс заходит в цикл \code{while (1)}, а пассивный -- вызывает \code{sleep(3)}. 

\lstinputlisting[caption=\code{father\_active\_passive.c}]{13_signals/father_active_passive.c}

\lstinputlisting[caption=\code{son\_active.c}]{13_signals/son_active.c}

\lstinputlisting[caption=\code{son\_passive.c}]{13_signals/son_passive.c}

\lstinputlisting[deletekeywords={while}]{13_signals/log2}

Из результатов видно, что \code{son\_passive} принимает сигнал прерывания ровно один раз, когда она еще не вошла в пассивный режим, после этого программа завершается и сигналы \code{SIGINT} больше не обрабатываются. Программа \code{son\_active} принимает все 4 прерывания, 3 из которых проходят через обработчик \code{handler()}. При получении 3-го прерывания восстанавливается реакция по умолчанию, поэтому при получении 4-го прерывания выполняется принудительное завершение программы.

\subsection{Утилиты \tcode{jobs}, \tcode{notify} и \tcode{fg}}

Запустим в фоновом режиме несколько утилит и используем утилиту \code{jobs} для вывода списка процессов.

\lstinputlisting{14_util/jobs}

С помощью \code{jobs -l} были получены утилиты, которые были запущены в фоновом режиме. С помощью команды \code{jobs -l \%\%} была получена команда, которая должна выполняться первой. Из результатов следует, что выполнение команд начинается с конца. С помощью утилиты \code{kill} была отменена 2-ая задача. Видно, что в списке \code{jobs -l} задача стала помечена как \code{Terminated} и больше не отображалась. С помощью команды \code{fg \%1} был повышен приоритет первой задачи, благодаря чему она стала выполнятся не в фоновом режиме.

\subsection{Системные вызовы \tcode{nice} и \tcode{getpriority}}

\code{nice(1)} -- утилита, запускающая программу с измененным приоритетом. Если не указано ни одного аргументы, команда выводит текущий унаследованный приоритет. В противном случае, \code{nice} запускает команду с указанным приоритетом. Если смещение не указано, то приоритет команды увеличивается на 10. команда nice может смещать приоритет в диапазоне от -20 до 19 включительно, когда используются права суперпользователя. Когда команда выполняется обычным пользователем, диапазон изменяется от 0 до 19.

\lstinputlisting[morekeywords={root@turing}]{14_util/nice}

Из результатов видно, что с помощью команды \code{nice -n} удалось изменить порядок выполнения процессов. При этом отрицательное значение приоритета (более приоритетный процесс) удалось только при выполнении с правами суперпользователя.

Функция \code{getpriority(int which, int who)} позволяет получить приоритет для процесса, группы и пользователя, в зависимости от заданных значений \code{which} (\code{PRIO\_PROCESS}, \code{PRIO\_USER}, \code{PRIO\_PGRP}) и \code{who} (идентификатор PID). Аналогично функция \code{setpriority(int which, int who, int priority)} позволяет установить приоритет. 

Программно определим границы приоритетов. Для этого используем программу \code{lim.c}

\lstinputlisting[caption=\code{lim.c}]{14_util/lim.c}

Из результатов выполнения программы видно, что для обычного пользователя диапазон приоритетов равен 0 -- 19, а для суперпользователя равен (-20) -- 20.
\lstinputlisting{14_util/log1}

Для того, чтобы сравнить приоритеты пользовательских и системных процессов, используем программу \code{priority.c}. Программа выводит свой приоритет и находит отличные от нуля приоритеты среди первых N процессов (аргумент командой строки).

\lstinputlisting[caption=\code{priority.c}]{14_util/priority.c}

Приведем результат выполнения при N = 20:
\lstinputlisting{14_util/log2}

Из результатов видно, что многие системные процессы имеют отрицательный (более высокий) приоритет, в то время как пользовательский процесс запустился с нулевым приоритетом.

\subsection{Утилита \tcode{nohup}}

\code{nohup(1)} -- утилита, позволяющая запустить команду, невосприимчивую к сигналам потери связи (\code{SIGHUP}), и чей вывод будет направлен не на терминал, а в файл \code{nohup.out}. Таким образом, команда будет выполняться в фоновом режиме даже тогда, когда пользователь выйдет из системы. 

Используем программу \code{loop.c}, которая в цикле выводит числа от 0 до 9, вызывая \code{sleep(2)} после каждой итерации. 

\lstinputlisting[caption=\code{loop.c}]{14_util/loop.c}

Запустим программу с использованием \code{nohup} в одном терминале и закроем его.

\lstinputlisting[lastline=3]{14_util/log3}

В новом терминале выполним просмотре текущих процессов. Видно, что несмотря на то, что первый терминал был закрыт и все процессы, запущенные из него, получили сигнал \code{SIGHUP}, программа \code{loop} продолжила свое выполнение, а ее стандартный вывод был перенаправлен в файл \code{nohup.out}.

\lstinputlisting[firstline=5]{14_util/log3}

\subsection{UID и PID процесса}

У каждого UNIX процесса есть 3 UID, ассоциированных с ним:

\begin{itemize}
	\item Real UID -- UID пользователя или процесса, который породил данный процесс;
	\item Effective UID -- UID, используемый для определения прав, предоставляемых процессу;
	\item Saved UID -- UID, получаемый процессом в начале до расширения прав с помощью флага SUID.
\end{itemize}

Минимальное и максимальное значение пользовательских UID можно найти в файле \code{/etc/login.defs}:
\lstinputlisting{14_util/logindefs}

Константа \code{UID\_MIN} определяет минимальный пользовательский UID. Множество допустимых значений UID зависит от системы; в общем случае UID допускает использование значений от 0 до 65535 с некоторыми оговорками:

\begin{itemize}
	\item Суперпользователь всегда должен иметь UID, равный нулю (0).
	\item Пользователю \code{nobody} обычно присваивается или наибольший из возможных UID (в противоположность суперпользователю), или один из системных UID.
	\item UID с 1 по 100 по соглашению резервируются под системные нужды; некоторые руководства рекомендуют резервировать UID со 101 по 499 (в Red Hat) или даже 999 (в Debian).
\end{itemize}

\lstinputlisting{14_util/ps}

Из результатов выполнения \code{ps} от имени пользователя и суперпользователя видно, что \code{bash} запущен от имени пользователя с UID = 1000, а суперпользователь имеет UID = 0.

Системные программы или системные приложения порождают системные процессы. Они инициализируются самой ОС или системными приложениями для выполнения функций управления ресурсами. Процессы, порождаемые пользователями (например, из командной строки в интерактивном режиме) или их приложениями называются пользовательскими. Важным системным процессом является процесс \code{init} с PID = 1. Он является предком всех процессов в Linux.

Максимальный возможный идентификатор процесса PID можно считать из файла \code{/proc/sys/kernel/pid\_max}.
\lstinputlisting{14_util/maxpid}

\section{Многонитевое функционирование}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item раз
	\item два
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Робачевский А. Операционная система UNIX [Текст] -- 2010.
	\item Уорд Б. Внутреннее устройство Linux [Текст] -- 2016.
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item Символические и жесткие ссылки Linux. [Электронный ресурс]:\\
		\url{https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux}
\end{enumerate}

\end{document}
