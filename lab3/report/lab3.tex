\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

\begin{itemize}
	\item Изучить основные принципы порождения и управления процессами и нитями в ОС UNIX на примере ОС Linux.
	\item Проанализировать использование функций семейства \code{exec} и \code{wait}. 
	\item Познакомиться с одним из видов IPC -- сигналами.
\end{itemize}

\section{Программа работы}

\input{workprogram}

\newpage

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Порождение и запуск процессов}

\subsection{Порождение процесса потомка}

Создадим программу на основе одного исходного файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка. Для создания копии текущего процесса используется системный вызов \code{fork}.
\lstinputlisting[caption=\code{fork.c}]{1_fork/fork.c}

После выполнения \code{fork} оба процесса продолжают выполнение с одной и той же точки. \code{fork} возвращает в породивший процесс идентификатор порожденного
процесса (\code{PID}), а в порожденный процесс -- \code{NULL}. В случае, если новый процесс не может быть порожден, возвращаемое значение равно \code{-1}.

\lstinputlisting{1_fork/log.txt}

Из результатов выполнения видно, что Parent \code{PID} (\code{PPID}) дочернего процесса равен \code{PID} родительского процесса.

При выполнении однократных вычислений в каждом процессе после порождения дочернего потока, родительский поток продолжает выполнение (печать и завершение), и лишь после этого начинает выполнятся порожденный процесс.

\subsection{Конкуренция за процессорный ресурс}

Если заменить однократные вычисления на циклы, длительность исполнения которых достаточна велика, можно наблюдать за конкуренцией между процессами за процессорный ресурс. 

\lstinputlisting[caption=\code{fight.c}]{3_fight/fight.c}

Программа выполняет вызов \code{fork}, выводит идентификатор выполняющегося процесса. В случае, если текущий процесс является потомком, то производится 1000 операций инкрементации переменной \code{n}, иначе (процесс является родителем) -- 1000 операций декремента переменной \code{m}. После завершения вычислений, выводится результат и сообщение о завершении вычислений.

\lstinputlisting{3_fight/log.txt}

Из результатов видно, что сначала полностью выполняется родитель и лишь после этого начинает выполнятся потомок.

\newpage

\subsection{Изменение процедуры планирования}

Повторим эксперимент с конкуренцией за процессорный ресурс, изменив при этом процедуру планирования, добавив вызов \code{usleep(1)} после каждой итерации.

\lstinputlisting[caption=\code{fight\_sleep.c}]{4_fight_sleep/fight_sleep.c}

Из результатов видно, что теперь процессы выполняются поочередно, при этом не определен порядок завершения их вычислений: при некоторых запусках родительский процесс завершится раньше, а при некоторых -- дочерний.

\lstinputlisting{4_fight_sleep/log.txt}

\subsection{Размещение родителя и потомка в разных файлах}
\label{sec:father-son}

Разработаем программы родителя и потомка с размещением в файлах \code{father.c} и \code{son.c}. Для фиксации состояния таблицы процессов в файле будем использовать системный вызов \code{system("ps xf > dump.txt")}.

\lstinputlisting[caption=\code{father.c}]{5_father_son/father.c}

\lstinputlisting[caption=\code{son.c}]{5_father_son/son.c}

\lstinputlisting{5_father_son/log.txt}

Из сохраняемого в файл \code{dump.txt} дерева процессов видно, что процесс \code{./parent} является родительским для \code{son}, что подтверждает выводимая в консоль информация о \code{PID} и \code{PPID} каждого из процессов.

\lstinputlisting{5_father_son/tree1.txt}

При выполнении \code{./father \&} интерпретатор запускает \code{father} в фоновом режиме, а параллельно ей запускается команда \code{ps -xf}. При завершении \code{father} добавляется строка \code{[1]+ Done}.

\lstinputlisting{5_father_son/tree2.txt}

\subsection{Использование функций семейства \tcode{exec}}

Для демонстрации использования разных функций семейства используем программу \code{exec.c}, в которой на примере утилиты \code{ls} показаны различия и возможности всех функций семейства.

\lstinputlisting[caption=\code{exec.c}]{8_exec/exec.c}

Вывод программы при различных значениях первого аргумента (\code{1} -- \code{6}) идентичен, а отличия составляет лишь способ вызова функции семейства \code{exec}. Суффиксы функций при этом означают:
\begin{itemize}
	\item \code{l} (list) -- аргументы командной строки передаются в форме списка \code{arg0}, \code{arg1}, \dots, \code{argN}, \code{NULL};
	\item \code{v} (vector) -- аргументы командной строки передаются в форме вектора \code{argv[]};
	\item \code{p} (path) -- обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды \code{PATH};
	\item \code{e} (environment) -- функция ожидает список переменных окружения в виде вектора \code{env[]}.
\end{itemize}

\subsection{Использование функций семейства \tcode{wait}}

Выполнение порождающего процесса может быть приостановлено до завершения потомка системным вызовом \code{wait}. Системный вызов \code{wait} возвращает родителю идентификатор того потомка, который завершился первым после последнего обращения к \code{wait}. Например, при выполнении программы в разделе \ref{sec:father-son} возвращаемое значение оказалось равно нулю. 

Для демонстрации использования функции \code{waitpid} используем программы \code{father\_wait.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Родительский процесс порождает 3 потомков, после чего ожидает их завершения (вызывая функцию \code{waitpid} с различными флагами). Дочерние процессы завершаются с кодом \code{0}, \code{1} и \code{-1} соответственно. После завершения всех порожденных процессов предок выводит информацию о завершении каждого процесса.

\lstinputlisting[caption=\code{father.c}]{9_wait/father.c}

\lstinputlisting[caption=\code{son1.c}]{9_wait/son1.c}

\lstinputlisting[caption=\code{son2.c}]{9_wait/son2.c}

\lstinputlisting[caption=\code{son3.c}]{9_wait/son3.c}

При вызове функции \code{waitpid} с параметрами \code{WNOHANG}, \code{WUNTRACED} и \code{WNOHANG} соответственно неуспешно завершился только вызов \code{waiapid} для первого процесса, т.к. он к моменту вызова \code{waitpid} с опцией \code{WNOHANG} еще не был завершен (при использовании опции \code{WNOHANG} управление возвращается сразу, если потомок еще не завершен).

\lstinputlisting{9_wait/log1.txt}
 
\subsection{Политики планирования}

В системах, следующих стандарту POSIX поддерживается три базовые политики планирования:
\begin{itemize}
	\item \code{SCHED\_FIFO} -- планировщик FIFO;
	\item \code{SCHED\_RR} -- циклический алгоритм планирования;
	\item \code{SCHED\_OTHER} -- стандартный алгоритм планировщика с	разделением времени.
\end{itemize}

Для удобства исследования политик планирования создадим файлы \code{utils.h} и \code{utils.c}, содержащие декларации и определения функций \code{print\_parameters} (печать PID и PPID), \code{print\_current\_priority} (печать политики и приоритета выполняемого процесса) и \code{set\_priority} (установка политики и приоритета процесса в зависимости от передаваемых параметров).

\lstinputlisting[caption=\code{utils.h}]{10_scheduler/utils.h}

\lstinputlisting[caption=\code{utils.c}]{10_scheduler/utils.c}

\subsubsection{Наследование политики планирования и приоритета}

Для анализа наследования политики планирования и приоритета исполнения процессов используем программы \code{father.c} и \code{son.c}.

\lstinputlisting[caption=\code{father.c}]{10_scheduler/father.c}

\lstinputlisting[caption=\code{son.c}]{10_scheduler/son.c}

При попытке исполнения программы от имени обычного пользователя, появляется сообщение об ошибке – о том, что операция изменения приоритета запрещена. При выполнении от имени суперпользователя программа работает корректно.

\lstinputlisting{10_scheduler/log1.txt}

Из результатов видно, что потомки наследуют политику планирования и приоритет родительского процесса.

\subsubsection{Очередность исполнения процессов, порожденных вложенными вызовами \tcode{fork()}}

Проанализируем очередность исполнения процессов, порожденных вложенными вызовами \code{fork}. Для этого создадим файл \code{nesting.c}, который порождает процесс (\code{son1}), внутри которого порождается еще один процесс (\code{son2}). Кроме того, в данном и последующих случаях нам необходимо, чтобы было использовано одно ядро процессора (чтобы контролировать планирование процессов). Для этого воспользуемся командой \code{taskset -c 1 ./program}, которая ограничивает количество используемых ядер при выполнении программы \code{./program}.

\lstinputlisting[caption=\code{nesting.c}]{10_scheduler/nesting.c}

\lstinputlisting{10_scheduler/log2.txt}

Из результатов видно, что процессы выполняются в порядке их порождения (от самого внешнего процесса -- родительского, до самого вложенного).

\subsubsection{Изменение процедуры планирования}

На основе \code{son.c} создадим файл \code{son\_calc.c}, внутри которой будем выполнять вычисления (увеличивать счетчик до миллиона), периодически сохраняя текущее время. После вычислений программа распечатывает список сохраненных времен. На основе этого списка можно будет сделать вывод о том, какой из процессов получил больший приоритет при планировании. 

\lstinputlisting[caption=\code{son\_calc.c}]{10_scheduler/son_calc.c}

Создадим программу \code{father\_priority.c}, которая будет порождать три процесса \code{son\_calc} с параметрами планирования, полученными через аргументы командой строки. 

\lstinputlisting[caption=\code{father\_priority.c}]{10_scheduler/father_priority.c}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_RR}. Видно, что так как приоритеты равны, то все три процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log3.txt}

Приведем результаты с отличающимися приоритетами процессов (один из приоритетов больше двух других) и политикой \code{SCHED\_RR}. Видно, что сначала выполняется процесс с большим приоритетом, после чего два оставшихся процесса выполняются поочередно.
\lstinputlisting{10_scheduler/log4.txt}

Приведем результаты с одинаковыми приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что так как приоритеты равны, процессы не были заблокированы запросами на ввод/вывод и не была вызвана функция \code{sched\_yield}, то все три процесса выполняются друг за другом (следующий начинает выполняться только после полного завершения предыдущего).
\lstinputlisting{10_scheduler/log5.txt}

Приведем результаты с отличающимися приоритетами процессов и политикой \code{SCHED\_FIFO}. Видно, что сначала выполняется процесс с большим приоритетом (30), после чего выбирается процесс с большим приоритетом среди оставшихся (20), после чего выполняется последний (10).
\lstinputlisting{10_scheduler/log6.txt}

Зададим разным процессам разные процедуры планирования с одинаковыми приоритетами. Для этого процесс \code{son1} будем запускать с процедурой планирования \code{SCHED\_FIFO} вне зависимости от входных данных.
\lstinputlisting{10_scheduler/log7.txt}
Из листинга видно, что сначала была выбрана процедура планирования \code{SCHED\_RR} и все процессы получили по кванту времени, а когда выполнение дошло до процесса с политикой \code{SCHED\_FIFO}, он захватил процессор. Оставшиеся процессы продолжили выполнение только после завершения процесса с политикой \code{SCHED\_FIFO}.

\subsubsection{Определение величины кванта}

Для определения величины кванта используем программу \code{interval.c}. Политика планирования задается с помощью аргумента командой строки.

\lstinputlisting[caption=\code{interval.c}]{10_scheduler/interval.c}

Из результатов запуска программы видно, что при политике планирования \code{SCHED\_RR} величина кванта равна 0.1 секунды, при \code{SCHED\_FIFO} -- 0 секунд, а при \code{SCHED\_OTHER} -- 0.02 секунды.

\lstinputlisting{10_scheduler/log8.txt}

\subsection{Наследование на этапах \tcode{fork} и \tcode{exec}}

Проанализируем наследование на этапах \code{fork()} и \code{exec()}. Для этого проведем эксперимент по проверке доступа потомков к файлам, открытым породившим их процессом. Рассмотрим пример кода, в котором в качестве аргументов процессам-потомкам передаются дескрипторы открытого и созданного родительским процессом файлов (в данном примере это \code{input.txt} и \code{output.txt} соответственно).

Порожденные процессы независимо друг от друга вызывают функции \code{read} и \code{write}, и в цикле считывают по одному байту информацию из исходного файла и переписывают ее в файл вывода. Для того чтобы пронаблюдать одновременный доступ порожденных процессов к файлам, добавим вызов \code{sched\_yield()} после вывода каждого символа. Данный вызов ставит процесс в конец очереди процессов с одинаковым статическим приоритетом.

\lstinputlisting[caption=\code{father.c}]{11_inheritance/father.c}

\lstinputlisting[caption=\code{son.c}]{11_inheritance/son.c}

Результат выполнения программы:

\lstinputlisting{11_inheritance/log.txt}

Видно, что дескрипторы \code{fdrd} в обоих потомках указывают на запись в таблице файлов, соответствующую исходному файлу, а дескрипторы, подставляемые в качестве \code{fdwr}, на запись, соответствующую  вывода.

Ядро смещает внутрифайловые указатели после каждой операции чтения или записи, поэтому порожденные процессы никогда не обращаются вместе на чтение или запись по одному и тому же указателю или смещению внутри файла (из двух процессов-потомков считать одни и те же данные нельзя, только если заново открывать файл). В результате выполнения в выходной файл записалось содержимое входного файла.

Рассмотрим наследование остальных параметров при порождении потомков. Для этого запустим \code{father} в фоновом режиме и выполним команду \code{ps -e -o uid,gid,ruid,pid,ppid,pgid,tty,vsz,stat,command > tree}.

\lstinputlisting{11_inheritance/tree.txt}

Из содержимого файла \code{tree} видно, что от родителя наследуются UID, GID, RUID, PGID, TTY. Ранее на экспериментах было показано, что также наследуются приоритеты и политика планирования.

\section{Взаимодействие родственных процессов}

Родственными считаются процессы, ближайшие в дереве процессов, т.е. породивший и порожденные им процессы. Их взаимодействие основывается на наследовании и существенно проще по сравнению с взаимодействием независимых процессов, поскольку независимые процессы полностью изолированы друг от друга и нуждаются в посреднике при обмене информацией в виде ядра ОС. 

Для наблюдения за взаимодействием родственных процессов создадим программы \code{father.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}.

\lstinputlisting[caption=\code{father.c}]{12_interaction/father.c}

\lstinputlisting[caption=\code{son1.c}]{12_interaction/son1.c}

\lstinputlisting[caption=\code{son2.c}]{12_interaction/son2.c}

\lstinputlisting[caption=\code{son3.c}]{12_interaction/son3.c}

Полученные результаты:
\begin{enumerate}
	\item Родитель порождает \code{son1} и дожидается его завершения. 
	\item В программе \code{son2} для увеличения длительности существования потомка используется задержка 10 секунд. В результате более раннего завершения родителя потомок становится наследником процесса \code{systemd} (\code{PID} = 2015). Из результатов видно, что как только родительский процесс завершается, на консоли сразу же появляется приглашение на ввод команды. Но так как время выполнения \code{son2} больше, результат выполнения son2 появляется уже после приглашения.
	\item Родитель порождает \code{son3} и не ожидает его завершения. В таком случае процесс получает статус zombie (процесс остается формально существующим, но ресурсы, отведенные для него, освобождаются).
\end{enumerate}

\lstinputlisting[deletekeywords={for}]{12_interaction/log.txt}

\lstinputlisting{12_interaction/tree.txt}

Из дерева процессов видно, что \code{son1} выполнился нормально, \code{son2} сменил родителя и перешел в <<самостоятельную>> ветку, \code{son3} оказался в состоянии zombie (\code{<defunct>}).

\section{Управление процессами посредством сигналов}

Сигналы позволяют осуществить самый примитивный способ
коммуникации между двумя процессами. Сигналы в системе UNIX  используются для того, чтобы сообщить процессу о том, что возникло какое-либо событие или необходимо обработать
исключительное состояние. 

\subsection{Генерация и реагирование на сигналы}

Для изучения генерации и реагирования на сигналы используем программу \code{father.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Процесс \code{father} порождает процессы \code{son1}, \code{son2}, \code{son3} и запускает на исполнение программные коды из соответствующих исполнительных файлов. Далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу. Процесс \code{son1} реагирует на сигнал по умолчанию, \code{son2} -- игнорирует сигнал, а \code{son3} -- перехватывает и обрабатывает сигнал.

\lstinputlisting[caption=\code{father.c}]{13_signals/father.c}

\lstinputlisting[caption=\code{son1.c}]{13_signals/son1.c}

\lstinputlisting[caption=\code{son2.c}]{13_signals/son2.c}

\lstinputlisting[caption=\code{son3.c}]{13_signals/son3.c}

Приведем результаты выполнения программы \code{father} и файл \code{signals}, содержащий информацию о сигналах, полученную с помощью вызова \code{ps -s}.

\lstinputlisting{13_signals/log1.txt}

\lstinputlisting{13_signals/signals.txt}

Из результатов видно, что:
\begin{itemize}
	\item порожденный процесс \code{son1}, установивший обработчик по умолчанию, был прерван и не был завершен;
	\item порожденный процесс \code{son2}, установивший игнорирование сигнала, не был прерван сигналом. В поле \code{IGNORED} установлено значение \code{2}, обозначающее номер игнорируемого сигнала (\code{SIGINT});
	\item порожденный процесс \code{son3}, установивший свой обработчик сигнала, был прерван и был вызван установленный обработчик, после чего выполнение программы продолжилось. В поле \code{CAUGHT} установлено значение \code{2}, обозначающее номер перехватываемого сигнала (\code{SIGINT}).
\end{itemize}

\subsection{Посылка сигналов процессам в активном и пассивном состоянии}

Для анализа различий обработки сигналов в зависимости от состояния процесса создадим программы \code{father\_active\_passive.c}, \code{son\_active.c} и \code{son\_passive.c}. Порождаемые процессы отличаются состоянием: после инициализации активный процесс заходит в цикл \code{while (1)}, а пассивный -- вызывает \code{sleep(3)}. 

\lstinputlisting[caption=\code{father\_active\_passive.c}]{13_signals/father_active_passive.c}

\lstinputlisting[caption=\code{son\_active.c}]{13_signals/son_active.c}

\lstinputlisting[caption=\code{son\_passive.c}]{13_signals/son_passive.c}

\lstinputlisting[deletekeywords={while}]{13_signals/log2.txt}

Из результатов видно, что \code{son\_passive} принимает сигнал прерывания ровно один раз, когда она еще не вошла в пассивный режим, после этого программа завершается и сигналы \code{SIGINT} больше не обрабатываются. Программа \code{son\_active} принимает все 4 прерывания, 3 из которых проходят через обработчик \code{handler()}. При получении 3-го прерывания восстанавливается реакция по умолчанию, поэтому при получении 4-го прерывания выполняется принудительное завершение программы.

\subsection{Утилиты \tcode{jobs} и \tcode{fg}}

Запустим в фоновом режиме несколько утилит и используем утилиту \code{jobs} для вывода списка процессов.

\lstinputlisting{14_util/jobs.txt}

С помощью \code{jobs -l} были получены утилиты, которые были запущены в фоновом режиме. С помощью команды \code{jobs -l \%\%} была получена команда, которая должна выполняться первой. Из результатов следует, что выполнение команд начинается с конца. С помощью утилиты \code{kill} была отменена 2-ая задача. Видно, что в списке \code{jobs -l} задача стала помечена как \code{Terminated} и больше не отображалась. С помощью команды \code{fg \%1} был повышен приоритет первой задачи, благодаря чему она стала выполнятся не в фоновом режиме.

\subsection{Системные вызовы \tcode{nice} и \tcode{getpriority}}

\code{nice(1)} -- утилита, запускающая программу с измененным приоритетом. Если не указано ни одного аргументы, команда выводит текущий унаследованный приоритет. В противном случае, \code{nice} запускает команду с указанным приоритетом. Если смещение не указано, то приоритет команды увеличивается на 10. команда nice может смещать приоритет в диапазоне от -20 до 19 включительно, когда используются права суперпользователя. Когда команда выполняется обычным пользователем, диапазон изменяется от 0 до 19.

\newpage

\lstinputlisting[morekeywords={root@turing}]{14_util/nice.txt}

Из результатов видно, что с помощью команды \code{nice -n} удалось изменить порядок выполнения процессов. При этом отрицательное значение приоритета (более приоритетный процесс) удалось только при выполнении с правами суперпользователя.

Функция \code{getpriority(int which, int who)} позволяет получить приоритет для процесса, группы и пользователя, в зависимости от заданных значений \code{which} (\code{PRIO\_PROCESS}, \code{PRIO\_USER}, \code{PRIO\_PGRP}) и \code{who} (идентификатор PID). Аналогично функция \code{setpriority(int which, int who, int priority)} позволяет установить приоритет. 

Программно определим границы приоритетов. Для этого используем программу \code{lim.c}

\lstinputlisting[caption=\code{lim.c}]{14_util/lim.c}

Из результатов выполнения программы видно, что для обычного пользователя диапазон приоритетов равен 0 -- 19, а для суперпользователя равен (-20) -- 20.
\lstinputlisting{14_util/log1.txt}

Для того, чтобы сравнить приоритеты пользовательских и системных процессов, используем программу \code{priority.c}. Программа выводит свой приоритет и находит отличные от нуля приоритеты среди первых N процессов (аргумент командой строки).

\lstinputlisting[caption=\code{priority.c}]{14_util/priority.c}

Приведем результат выполнения при N = 20:
\lstinputlisting{14_util/log2.txt}

Из результатов видно, что многие системные процессы имеют отрицательный (более высокий) приоритет, в то время как пользовательский процесс запустился с нулевым приоритетом.

\subsection{Утилита \tcode{nohup}}

\code{nohup(1)} -- утилита, позволяющая запустить команду, невосприимчивую к сигналам потери связи (\code{SIGHUP}), и чей вывод будет направлен не на терминал, а в файл \code{nohup.out}. Таким образом, команда будет выполняться в фоновом режиме даже тогда, когда пользователь выйдет из системы. 

Используем программу \code{loop.c}, которая в цикле выводит числа от 0 до 9, вызывая \code{sleep(2)} после каждой итерации. 

\lstinputlisting[caption=\code{loop.c}]{14_util/loop.c}

Запустим программу с использованием \code{nohup} в одном терминале и закроем его.

\lstinputlisting[lastline=3]{14_util/log3.txt}

В новом терминале выполним просмотре текущих процессов. Видно, что несмотря на то, что первый терминал был закрыт и все процессы, запущенные из него, получили сигнал \code{SIGHUP}, программа \code{loop} продолжила свое выполнение, а ее стандартный вывод был перенаправлен в файл \code{nohup.out}.

\lstinputlisting[firstline=5]{14_util/log3.txt}

\subsection{UID и PID процесса}

У каждого UNIX процесса есть 3 UID, ассоциированных с ним:

\begin{itemize}
	\item Real UID -- UID пользователя или процесса, который породил данный процесс;
	\item Effective UID -- UID, используемый для определения прав, предоставляемых процессу;
	\item Saved UID -- UID, получаемый процессом в начале до расширения прав с помощью флага SUID.
\end{itemize}

Минимальное и максимальное значение пользовательских UID можно найти в файле \code{/etc/login.defs}:
\lstinputlisting{14_util/logindefs}

Константа \code{UID\_MIN} определяет минимальный пользовательский UID. Множество допустимых значений UID зависит от системы; в общем случае UID допускает использование значений от 0 до 65535 с некоторыми оговорками:

\begin{itemize}
	\item Суперпользователь всегда должен иметь UID, равный нулю (0).
	\item Пользователю \code{nobody} обычно присваивается или наибольший из возможных UID (в противоположность суперпользователю), или один из системных UID.
	\item UID с 1 по 100 по соглашению резервируются под системные нужды; некоторые руководства рекомендуют резервировать UID со 101 по 499 (в Red Hat) или даже 999 (в Debian).
\end{itemize}

\lstinputlisting{14_util/ps.txt}

Из результатов выполнения \code{ps} от имени пользователя и суперпользователя видно, что \code{bash} запущен от имени пользователя с UID = 1000, а суперпользователь имеет UID = 0.

Системные программы или системные приложения порождают системные процессы. Они инициализируются самой ОС или системными приложениями для выполнения функций управления ресурсами. Процессы, порождаемые пользователями (например, из командной строки в интерактивном режиме) или их приложениями называются пользовательскими. Важным системным процессом является процесс \code{init} с PID = 1. Он является предком всех процессов в Linux.

Максимальный возможный идентификатор процесса PID можно считать из файла \code{/proc/sys/kernel/pid\_max}.
\lstinputlisting{14_util/maxpid.txt}

\section{Многонитевое функционирование}

Потоки (нити, lightweight processes, легковесные процессы) рассматриваются обязательно как часть процесса, в который они входят, и разделяют ресурсы этого процесса наравне с другими потоками этого процесса (адресное пространство, файловые дескрипторы, обработчики сигналов и т.д.). При создании новых потоков в рамках существующего процесса им нет необходимости создавать собственную копию адресного пространства (и других ресурсов) своего родителя, поэтому требуется значительно меньше затрат, чем при создании нового дочернего процесса.

\subsection{Создание нитей}

Для изучения нитей используем программу \code{threads.c}. В программе с использованием библиотеки \code{pthread} создаются две нити с помощью функции \code{pthread\_create}, после чего происходит ожидание завершения этих нитей с помощью вызова \code{pthread\_join}. При этом до создания нитей, после создания и после их выполнения делается снимок списка процессов. Для компиляции необходим флаг \code{-pthread} как указано в \code{CMakeLists.txt}.

\lstinputlisting[caption=\code{threads.c}]{18_threads/threads.c}

\lstinputlisting[caption=\code{CMakeLists.txt}]{18_threads/CMakeLists.txt}

Выполним программу \code{threads}.

\lstinputlisting{18_threads/log1.txt}

Из результатов выполнения видно, что было создано 2 потока \code{thread1} и \code{threadn}. Пока в \code{thread1} выполняется команда \code{sleep(5)}, поток \code{threadn} успевает вывести 5 сообщении и выполнить команду \code{sleep(1)} 5 раз.

\lstinputlisting{18_threads/dump1_1.txt}

\lstinputlisting{18_threads/dump2_1.txt}

\lstinputlisting{18_threads/dump3_1.txt}

Из списка процессов видно, что PID потоков совпадает с PID процесса, в котором они запущены, при этом отличаются значения LWP (Light Weight Process). Нумерация PID процессов, запускаемых после создания нитей, продолжается начиная с последнего значения LWP.

\subsection{Удаление нитей}

Попробуем удалить нить с помощью команды \code{kill}. Для этого изменим программу \code{threads.c} и сохраним в \code{threads\_kill.c}, изменив код первого потока. В начале потока выполняется вызов \code{syscall} для получения TID (Thread ID), после чего выполняется команда \code{kill -9} с номером TID.

\lstinputlisting[caption={(частичный) \code{threads\_kill.c}}, linerange=7-17]{19_threads_kill/threads_kill.c}

Результат выполнения \code{thread\_kill}:

\lstinputlisting{19_threads_kill/log1.txt}

Из результатов видно, что при попытке завершить поток обычным способом с помощью команды kill, завершается все многопоточное приложение, хотя был использован TID потока \code{thread1}.

Список процессов после создания потоков:

\lstinputlisting{19_threads_kill/dump2_1.txt}

Видно, что приложение успело вызвать команду \code{ps} до получения приложением сигнала \code{kill}, но в таблице PPID для команды \code{ps} указан процесс \code{systemd} (PID = 1896).

\subsection{Управление нитью}

Модифицируем программу так, чтобы управлять второй нитю посредством сигнала \code{SIGUSR1} из первой нити. Для этого сделаем идентификаторы потоков глобальными переменными и отправим сигнал потоку \code{threadn} из \code{thread1} с помощью вызова \code{pthread\_kill}.

\lstinputlisting[caption=\code{threads\_signal.c}]{20_threads_signal/threads_signal.c}

Результат выполнения \code{thread\_signal}:

\lstinputlisting{20_threads_signal/log1.txt}

Из результатов видно, что из-за того, что не был установлен обработчик сигнала, после получения сигнала завершается не только поток \code{threadn}, а все приложение.

\subsection{Добавление обработчика сигнала}

Создадим собственный обработчик сигнала, содержащий уведомление о начале его работы и возврат посредством функции \code{pthread\_exit}. Для этого добавим обработчик сигнала \code{handler} для сигнала \code{SIGUSR1}.

\lstinputlisting[caption=\code{threads\_handler.c}]{21_threads_handler/threads_handler.c}

Результат выполнения \code{thread\_handler}:

\lstinputlisting{21_threads_handler/log1.txt}

Из результатов видно, что теперь удалось с помощью сигнала и обработчика завершить одну нить, а не все приложение. 

\subsection{Перехват сигнала \ctrl{C}}

Перехватим сигнал \ctrl{C} в процессе. Число раз, которое должен сработать обработчик сигнала, будем получать из командной строки. При этом если число не задано, то сигнал перехватывается ровно один раз, после чего восстанавливается исходный обработчик сигнала.

\lstinputlisting[caption=\code{process\_ctrl\_c.c}]{22_ctrl_c/process_ctrl_c.c}

Выполним \code{process\_ctrl\_c.c} с разным значением входного параметра:

\lstinputlisting[deletekeywords={for,default}]{22_ctrl_c/log1.txt}

Из результатов видно, что при запуске без параметров (эквивалентно запуску с параметром, равным единице), обработчик выполнился одни раз, после чего восстановил стандартный обработчик. Из-за этого, следующий сигнал \code{SIGINT} был обработан стандартным обработчиком и процесс был завершен.

При запуске с параметром, равным 3, наш обработчик выполнился три раза и только после этого восстановил стандартный обработчик. Программа была завершена после получения четвертого сигнала \code{SIGINT}.

Перехватим сигнал \ctrl{C} в потоке. Аналогично предыдущей программе, число раз, которое должен сработать обработчик сигнала, будем получать из командной строки.

\lstinputlisting[caption=\code{threads\_ctrl\_c.c}]{22_ctrl_c/threads_ctrl_c.c}

Выполним \code{thread\_ctrl\_c.c} с разными значениями входного параметра:

\lstinputlisting[deletekeywords={for,default}]{22_ctrl_c/log2.txt}

Результаты запуска оказались аналогичны предыдущей программе.

Продемонстрируем подобную обработку для сигнала \code{SIGTSTP}, что соответствует сочетанию \ctrl{Z}. Для этого модифицируем программу \code{process\_ctrl\_c}, заменив \code{SIGINT} на \code{SIGTSTP}.

\lstinputlisting[caption=\code{process\_ctrl\_z.c}]{22_ctrl_c/process_ctrl_z.c}

Выполним с разными параметрами:

\lstinputlisting[deletekeywords={for,default}]{22_ctrl_c/log3.txt}

Из результатов видно, что обработчик успешно перехватывал сигнал \code{SIGTSTP} нужное количество раз, после чего восстанавливал исходный обработчик. Из-за этого следующее нажатие \ctrl{Z} приводило к приостановлению выполнения программы. Для того чтобы продолжить выполнение использовалась утилита \code{fg}, рассмотренная ранее.

\newpage

\subsection{Использование \ctrl{C} для завершения нити}

Создадим программу \code{ctrl\_c.c}, внутри которой создаются две нити, после чего они, наряду с главной нитью (\code{main}), в цикле отсчитывают до 10. Кроме этого, создадим обработчик сигнала (\code{handler}), который печатает TID нити, которая обрабатывает сигнал, после чего вызывает \code{pthread\_exit}.

\lstinputlisting[caption=\code{ctrl\_c.c}]{22_ctrl_c/ctrl_c.c}

Допустим наша задача -- завершить \code{thread1} при получении сигнала \code{SIGINT}. Для этого добавим строчку в первой ните: \code{signal(SIGINT, handler}). Выполним программу \code{ctrl\_c}:

\lstinputlisting{22_ctrl_c/log4.txt}

Из результатов видно, что при первом нажатии \ctrl{C} обрабатывала сигнала в \code{handler} нить с TID = 9277, что соответствует главной ните. После этого выполнение цикла в функции \code{main} прекратилось. После второго нажатия \ctrl{C} сигнал обрабатывала нить с TID = 9278 (\code{thread1}), после чего цикл внутри этой нити также прекратился (нить завершилась). Третье нажатие \ctrl{C} обрабатывала единственная оставшаяся нить -- \code{threadn}. В конце обработчика вызвалась функция \code{pthread\_exit} и программа завершилась. Таким образом, использование сигналов для управления нитями затруднено.

\subsection{Список сигналов}

С помощью команды \code{singal -l} получим список поддерживаемых сигналов. Сигналы 1 -- 31 являются базовыми, а остальные -- расширенными.

\lstinputlisting{23_signals/list.txt}

Изначально были разработаны и использовались простые (ненадежные) сигналы. По своему принципу работы они похожи на канонический механизм обработки аппаратных прерываний в процессоре. Если процесс хочет особым образом обрабатывать некий сигнал, то он сообщает ядру об этом, указывая специальную функцию – обработчик сигнала. При доставке сигнала процессу ядро как можно скорее вызывает обработчик сигнала, прерывая работу процесса. По завершении работы обработчика выполнение процесса продолжается с того места, где он был прерван. Приведем краткое описание базовых сигналов:
\begin{enumerate}[itemsep=-0.2em]
	\item \code{SIGHUP} - Закрытие терминала
	\item \code{SIGINT} -- Сигнал прерывания (\ctrl{C}) с терминала
	\item \code{SIGQUIT} -- Сигнал выхода из терминала (\ctrl{$\backslash$})
	\item \code{SIGILL} -- Несуществующая инструкция
	\item \code{SIGTRAP} -- Ловушка трассировки или ловушка
	\item \code{SIGABRT} -- Сигнал, посланный функцией \code{abort}
	\item \code{SIGBUS} -- Неправильное обращение в физическую память
	\item \code{SIGFPE} -- Ошибочная арифметическая операция
	\item \code{SIGKILL} -- Безусловное завершение
	\item \code{SIGUSR1} -- Пользовательский сигнал №1
	\item \code{SIGSEGV} -- Нарушение при обращении к памяти
	\item \code{SIGUSR2} -- Пользовательский сигнал №2
	\item \code{SIGPIPE} -- Запись в разорванное соединение (пайп, сокет)
	\item \code{SIGALRM} -- Сигнал истечения времени, заданного \code{alarm()}
	\item \code{SIGTERM} -- Сигнал завершения
	\item \code{SIGSTKFLT} -- Переполнение стека сопроцессора
	\item \code{SIGCHLD} -- Потомок остановлен или прекратил выполнение
	\item \code{SIGCONT} -- Продолжить выполнение ранее остановленного процесса 
	\item \code{SIGSTOP} -- Остановка выполнения процесса
	\item \code{SIGTSTP} -- Сигнал остановки с терминала (\ctrl{Z})
	\item \code{SIGTTIN} -- ввод с терминала у фонового процесса
	\item \code{SIGTTOU} -- вывод на терминал у фонового процесса
	\item \code{SIGURG} -- На сокете получены срочные данные
	\item \code{SIGXCPU} -– Процесс превысил предел процессорного времени
	\item \code{SIGXFSZ} -- Процесс превысил допустимый размер файла
	\item \code{SIGVTALRM} -- Виртуальный будильник
	\item \code{SIGPROF} -- Закончилось время профилирующего таймера
	\item \code{SIGWINCH} -- Изменение размеров окна
	\item \code{SIGIO} -- I/O теперь возможно
	\item \code{SIGPWR} -- Авария питающего напряжения
	\item \code{SIGSYS} -- Неправильный аргумент процедуры
\end{enumerate}

Начиная с 32 указаны сигналы реального времени. Они были разработаны в процессе поиска решения проблемы появления сигнала во время обработки другого сигнала и имеют несколько ключевых отличий от базовых.

Сигналы реального времени помещаются в очередь, если сигнал будет порожден несколько раз, он будет несколько раз получен адресатом. Повторения одного и того же сигнала доставляются в порядке очереди FIFO. Если сигналы в очередь не помещаются, неоднократно порожденный сигнал будет получен лишь один раз. Сигналы реального времени с меньшим номером будут обработаны раньше. Если же одновременно посылаются несколько обычных сигналов, то они сливаются в один.

Рассмотрим отличия сигналов с помощью программы \code{rtsignals.c}

\lstinputlisting[caption=\code{rtsignals.c}]{23_signals/rtsignals.c}

Выполним \code{rtsignals.c}:

\lstinputlisting{23_signals/log1.txt}

Из результатов видно, что:
\begin{itemize}
	\item Сигналы реального времени имеют больший приоритет в сравнении с базовыми сигналами;
	\item Сигналы реального времени с большим номером имеют больший приоритет перед сигналами реального времени с меньшими номерами;
	\item Обычные сигналы пришли не в том порядке;
	\item Одинаковые сигналы реального времени не слились в один, в отличии от базовых;
	\item Сигнал \code{SIGKILL} невозможно перехватить.
\end{itemize}

\subsection{Процедура планирования для процессов и потоков одного процесса}

Для анализа процедуры планирования для нитей создадим файл \code{utils.c} с функциями вывода текущей процедуры планирования и установки процедуры планирования как для процесса, так и для нити.

\lstinputlisting[caption=\code{utils.c}]{24_inheritance/utils.c}

Для анализа наследования и установки процедуры планирования будем использовать программу \code{inheritance.c}. В ней процесс устанавливает себе процедуру планирования \code{SCHED\_RR} с приоритетом равным 30. После этого, он создает две нити, внутри которых происходят вычисления и фиксируется промежуточное время.

\newpage

\lstinputlisting[caption=\code{inheritance.c}]{24_inheritance/inheritance.c}

При этом будем изменять в первой ните устанавливаемые значения планирования. Сначала закомментируем эту строку.

\newpage

\lstinputlisting{24_inheritance/log1.txt}

Из вывода видно, что нити наследуют процедуру и параметры планирования процесса, который создает эти нити. В данном случае обе нити наследуют процедуру планирования Round-Robin, что соответствуют выполнению нитей в течении фиксированного кванта времени. Из сохраненных во время вычислений значений времени видно, что нити выполнялись в режиме разделения времени.

Теперь в первой ните вызовем функци\code{set\_thread\_priority(SCHED\_RR, 50)} (повысим приоритет нити, оставив процедуру планирования):

\lstinputlisting{24_inheritance/log2.txt}

Из вывода программы видно, что первая нить, обладающая большим приоритетом, захватила процессорное время до конца вычислений.

\newpage

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item изучены семейства функций порождения в процессе потомков, изменения процедуры планирования и ожидания;
	\item рассмотрено взаимодействие родственных процессов;
	\item проанализированы сигналы как метод управления процессами;
	\item рассмотрены утилиты \code{jobs}, \code{fg} и \code{nohup};
	\item изучено многонитевое функционирование: создание и удаление нитей, обработка сигналов внутри нитей, задание процедуры планирования.
\end{itemize}

\section*{Список использованных источников}

\begin{enumerate}
	\item Робачевский А. Операционная система UNIX [Текст] -- 2010.
	\item Уорд Б. Внутреннее устройство Linux [Текст] -- 2016.
	\item Таненбаум Э. - Современные операционные системы [Текст] -- 2015.
	\item Керриск М. - Linux API. Исчерпывающее руководство [Текст] -- 2018.
	\item Работа с сигналами в Linux. [Электронный ресурс]:\\
		{\small\url{http://manpages.ubuntu.com/manpages/precise/ru/man7/signal.7.html}} 
	\item Signal (IPC). [Электронный ресурс]:\\
		{\small\url{https://en.wikipedia.org/wiki/Signal_(IPC)}}
	\item Изучение создания процесса UNIX. [Электронный ресурс]:\\
		{\small\url{https://www.ibm.com/developerworks/ru/library/au-unixprocess/index.html}}
	\item Семейство функций exec. [Электронный ресурс]:\\
		{\small\url{https://www.opennet.ru/man.shtml?topic=exec}}
	\item Планирование процессов. [Электронный ресурс]:\\
		{\small\url{http://dmilvdv.narod.ru/Translate/ELSDD/elsdd_process_scheduling.html}}
	\item Квант времени. Разработка ядра Linux. [Электронный ресурс]:\\
		{\small\url{https://it.wikireading.ru/1747}}
\end{enumerate}

\newpage

%\section*{Дополнения к отчету}
%
%\subsection*{Использование \ctrl{C} для завершения нити}
%
%Создадим программу \code{ctrl\_c.c}, внутри которой создаются две нити, после чего они, наряду с главной нитью (\code{main}), в цикле отсчитывают до 10. Кроме этого, создадим обработчик сигнала (\code{handler}), который печатает TID нити, которая обрабатывает сигнал, после чего вызывает \code{pthread\_exit}.
%
%\lstinputlisting[caption=\code{ctrl\_c.c}]{22_ctrl_c/ctrl_c.c}
%
%Допустим наша задача -- завершить \code{thread1} при получении сигнала \code{SIGINT}. Для этого добавим строчку в первой ните: \code{signal(SIGINT, handler}). Выполним программу \code{ctrl\_c}:
%
%\lstinputlisting{22_ctrl_c/log4}
%
%Из результатов видно, что при первом нажатии \ctrl{C} обрабатывала сигнала в \code{handler} нить с TID = 9277, что соответствует главной ните. После этого выполнение цикла в функции \code{main} прекратилось. После второго нажатия \ctrl{C} сигнал обрабатывала нить с TID = 9278 (\code{thread1}), после чего цикл внутри этой нити также прекратился (нить завершилась). Третье нажатие \ctrl{C} обрабатывала единственная оставшаяся нить -- \code{threadn}. В конце обработчика вызвалась функция \code{pthread\_exit} и программа завершилась. Таким образом, использование сигналов для управления нитями затруднено.

\end{document}
