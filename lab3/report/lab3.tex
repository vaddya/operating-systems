\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цели работы}

\begin{itemize}
	\item раз
	\item два
\end{itemize}

\section{Используемая операционная система}

\begin{itemize}
	\item Дистрибутив: Ubuntu 18.04.1 LTS
	\item Процессоры: Intel® Core™ i7-4800MQ CPU @ 2.70GHz × 8
	\item Версия ядра: 4.15.0-34-generic
\end{itemize}

\section{Порождение и запуск процессов}

\subsection{Порождение процесса потомка}

Создадим программу на основе одного исходного файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка. Для создания копии текущего процесса используется системный вызов \code{fork}.
\lstinputlisting[caption=\code{fork.c}]{1/fork.c}

После выполнения \code{fork} оба процесса продолжают выполнение с одной и той же точки. \code{fork} возвращает в породивший процесс идентификатор порожденного
процесса (\code{PID}), а в порожденный процесс -- \code{NULL}. В случае, если новый процесс не может быть порожден, возвращаемое значение равно \code{-1}.

\lstinputlisting{1/log}

Из результатов выполнения видно, что Parent \code{PID} (\code{PPID}) дочернего процесса равен \code{PID} родительского процесса.

При выполнении однократных вычислений в каждом процессе после порождения дочернего потока, родительский поток продолжает выполнение (печать и завершение), и лишь после этого начинает выполнятся порожденный процесс.

%TODO Объясните результаты. Сделайте выводы об использовании адресного пространства.

\subsection{Конкуренция за процессорный ресурс}

Если заменить однократные вычисления на циклы, длительность исполнения которых достаточна велика, можно наблюдать за конкуренцией между процессами за процессорный ресурс. 

\lstinputlisting[caption=\code{fight.c}]{3/fight.c}

Программа выполняет вызов \code{fork}, выводит идентификатор выполняющегося процесса. В случае, если текущий процесс является потомком, то производится 1000 операций инкрементации переменной \code{n}, иначе (процесс является родителем) -- 1000 операций декремента переменной \code{m}. После завершения вычислений, выводится результат и сообщение о завершении вычислений.

\lstinputlisting{3/log}

Из результатов видно, что сначала полностью выполняется родитель и лишь после этого начинает выполнятся потомок.

\subsection{Изменение процедуры планирования}

Повторим эксперимент с конкуренцией за процессорный ресурс, изменив при этом процедуру планирования, добавив вызов \code{usleep(1)} после каждой итерации.

\lstinputlisting[caption=\code{fight\_sleep.c}]{4/fight_sleep.c}

Из результатов видно, что теперь процессы выполняются поочередно, при этом не определен порядок завершения их вычислений: при некоторых запусках родительский процесс завершится раньше, а при некоторых -- дочерний.

\lstinputlisting{4/log}

\subsection{Размещение родителя и потомка в разных файлах}
\label{sec:father-son}

Разработаем программы родителя и потомка с размещением в файлах \code{father.c} и \code{son.c}. Для фиксации состояния таблицы процессов в файле будем использовать системный вызов \code{system("ps xf > dump.txt")}.

\lstinputlisting[caption=\code{father.c}]{5/father.c}

\lstinputlisting[caption=\code{son.c}]{5/son.c}

\lstinputlisting{5/log}

Из сохраняемого в файл \code{dump.txt} дерева процессов видно, что процесс \code{./parent} является родительским для \code{son}, что подтверждает выводимая в консоль информация о \code{PID} и \code{PPID} каждого из процессов.

\lstinputlisting{5/tree1}

При выполнении \code{./father \&} интерпретатор запускает \code{father} в фоновом режиме, а параллельно ей запускается команда \code{ps -xf}. При завершении \code{father} добавляется строка \code{[1]+ Done}.

\lstinputlisting{5/tree2}

\subsection{Использование функций семейства \code{exec}}

Для демонстрации использования разных функций семейства используем программу \code{exec.c}, в которой на примере утилиты \code{ls} показаны различия и возможности всех функций семейства.

\lstinputlisting[caption=\code{exec.c}]{8/exec.c}

Вывод программы при различных значениях первого аргумента (\code{1} -- \code{6}) идентичен, а отличия составляет лишь способ вызова функции семейства \code{exec}. Суффиксы функций при этом означают:
\begin{itemize}
	\item \code{l} (list) -- аргументы командной строки передаются в форме списка \code{arg0}, \code{arg1}, \dots, \code{argN}, \code{NULL};
	\item \code{v} (vector) -- аргументы командной строки передаются в форме вектора \code{argv[]};
	\item \code{p} (path) -- обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды \code{PATH};
	\item \code{e} (environment) -- функция ожидает список переменных окружения в виде вектора \code{env[]}.
\end{itemize}

\subsection{Использование функций семейства \code{wait}}

Выполнение порождающего процесса может быть приостановлено до завершения потомка системным вызовом \code{wait}. Системный вызов \code{wait} возвращает родителю идентификатор того потомка, который завершился первым после последнего обращения к \code{wait}. Например, при выполнении программы в разделе \ref{sec:father-son} возвращаемое значение оказалось равно нулю. 

Для демонстрации использования функции \code{waitpid} используем программы \code{father\_wait.c}, \code{son1.c}, \code{son2.c} и \code{son3.c}. Родительский процесс порождает 3 потомков, после чего ожидает их завершения (вызывая функцию \code{waitpid} с различными флагами). Дочерние процессы завершаются с кодом \code{0}, \code{1} и \code{-1} соответственно. После завершения всех порожденных процессов предок выводит информацию о завершении каждого процесса.

\lstinputlisting[caption=\code{father\_wait.c}]{9/father_wait.c}

\lstinputlisting[caption=\code{son1.c}]{9/son1.c}

\lstinputlisting[caption=\code{son2.c}]{9/son2.c}

\lstinputlisting[caption=\code{son3.c}]{9/son3.c}

При вызове функции \code{waitpid} с параметрами \code{WNOHANG}, \code{WUNTRACED} и \code{WNOHANG} соответственно неуспешно завершился только вызов \code{waiapid} для первого процесса, т.к. он к моменту вызова \code{waitpid} с опцией \code{WNOHANG} еще не был завершен (при использовании опции \code{WNOHANG} управление возвращается сразу, если потомок еще не завершен).

\lstinputlisting{9/log1}
 

\section{Взаимодействие родственных процессов}

\section{Управление процессами посредством сигналов}

\section{Многонитевое функционирование}

\section{Выводы}

В процессе выполнения данной работы:
\begin{itemize}
	\item раз
	\item два
\end{itemize}


\end{document}
